<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>⚔️ NEON KNIGHTS: Castle Defense ⚔️</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
      
      :root {
        --neon-pink: #ff00ff;
        --neon-blue: #00ffff;
        --neon-purple: #bf00ff;
        --neon-yellow: #ffff00;
        --dark-bg: #0a0014;
        --panel-bg: #1a0033;
        --gold: #ffd700;
        --text: #ffffff;
      }
      
      @keyframes neonPulse {
        0%, 100% { filter: brightness(1) drop-shadow(0 0 20px var(--neon-pink)); }
        50% { filter: brightness(1.3) drop-shadow(0 0 40px var(--neon-blue)); }
      }
      
      @keyframes neonGlow {
        0%, 100% { box-shadow: 0 0 20px #ff00ff, inset 0 0 20px rgba(255,0,255,0.1); }
        50% { box-shadow: 0 0 40px #00ffff, inset 0 0 40px rgba(0,255,255,0.1); }
      }
      
      @keyframes textGlow {
        0%, 100% { text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px #ffffff; }
        50% { text-shadow: 0 0 10px #cccccc, 0 0 20px #cccccc, 0 0 30px #cccccc; }
      }
      
      @keyframes float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
      }
      
      @keyframes shimmer {
        0%, 100% { 
          background: linear-gradient(135deg, rgba(0,0,0,0.3), rgba(255,255,255,0.1));
          box-shadow: 0 0 20px rgba(255,255,255,0.6);
        }
        25% { 
          background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(0,0,0,0.4));
          box-shadow: 0 0 30px rgba(255,255,255,0.8);
        }
        50% { 
          background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(255,255,255,0.2));
          box-shadow: 0 0 40px rgba(255,255,255,1.0);
        }
        75% { 
          background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(0,0,0,0.3));
          box-shadow: 0 0 25px rgba(255,255,255,0.7);
        }
      }
      
      @keyframes sparkle {
        0%, 100% { 
          opacity: 0;
          transform: scale(0) rotate(0deg);
        }
        50% { 
          opacity: 1;
          transform: scale(1) rotate(180deg);
        }
      }
      
      @keyframes borderShimmer {
        0%, 100% { 
          border-image: linear-gradient(45deg, #000000, #ffffff, #000000) 1;
        }
        25% { 
          border-image: linear-gradient(45deg, #ffffff, #000000, #ffffff) 1;
        }
        50% { 
          border-image: linear-gradient(45deg, #000000, #ffffff, #000000) 1;
        }
        75% { 
          border-image: linear-gradient(45deg, #ffffff, #000000, #ffffff) 1;
        }
      }
      
      @keyframes heroicShimmer {
        0%, 100% { 
          background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(255,255,255,0.15), rgba(255,215,0,0.1));
          box-shadow: 0 0 30px rgba(255,255,255,0.8), 0 0 60px rgba(255,215,0,0.6);
        }
        25% { 
          background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(0,0,0,0.5), rgba(255,215,0,0.15));
          box-shadow: 0 0 40px rgba(255,255,255,1.0), 0 0 80px rgba(255,215,0,0.8);
        }
        50% { 
          background: linear-gradient(135deg, rgba(0,0,0,0.5), rgba(255,255,255,0.2), rgba(255,215,0,0.1));
          box-shadow: 0 0 50px rgba(255,255,255,1.2), 0 0 100px rgba(255,215,0,1.0);
        }
        75% { 
          background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(0,0,0,0.4), rgba(255,255,255,0.15));
          box-shadow: 0 0 35px rgba(255,255,255,0.9), 0 0 70px rgba(255,215,0,0.7);
        }
      }
      
      @keyframes heroicBorder {
        0%, 100% { 
          border-image: linear-gradient(45deg, #000000, #ffffff, #ffd700, #000000) 1;
        }
        25% { 
          border-image: linear-gradient(45deg, #ffffff, #ffd700, #000000, #ffffff) 1;
        }
        50% { 
          border-image: linear-gradient(45deg, #ffd700, #000000, #ffffff, #ffd700) 1;
        }
        75% { 
          border-image: linear-gradient(45deg, #000000, #ffffff, #ffd700, #000000) 1;
        }
      }
      
      @keyframes heroicSparkle {
        0%, 100% { 
          opacity: 0;
          transform: scale(0) rotate(0deg);
          filter: hue-rotate(0deg);
        }
        25% { 
          opacity: 1;
          transform: scale(1.2) rotate(90deg);
          filter: hue-rotate(90deg);
        }
        50% { 
          opacity: 1;
          transform: scale(1) rotate(180deg);
          filter: hue-rotate(180deg);
        }
        75% { 
          opacity: 0.8;
          transform: scale(0.8) rotate(270deg);
          filter: hue-rotate(270deg);
        }
      }
      
      /* Radiant Aegis Fire Animations */
      @keyframes flameMovement {
        50% {
          transform: scale(0.98,1.0) translate(0, 2px) rotate(-1deg);
        }
      }
      
      @keyframes flameDisappear {
        0%{
          transform: translate(0) rotate(180deg);
        }
        50% {
           opacity: 1;
        }
        100% {
          transform: translate(-10px, -40px) rotate(180deg);
          opacity: 0;
        }
      }
      
      .radiant-flame {
        animation-name: flameDisappear;
        animation-duration: 2s;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
        opacity: 0.5;
        transform-origin: 45% 45% 0;
      }
      
      .radiant-flame.one {
        animation-delay: 1s;
        animation-duration: 3s;
      }
      
      .radiant-flame.two{
        animation-duration: 5s;
        animation-delay: 1s;
      }
      
      .radiant-flame-main {
        animation-name: flameMovement;
        animation-duration: 2s;
        animation-timing-function: ease-in-out;
        animation-iteration-count: infinite;
      }
      
      .radiant-flame-main.one {
        animation-duration: 2.2s;
        animation-delay: 1s;
      }
      
      .radiant-flame-main.two {
        animation-duration: 2s;
        animation-delay: 1s;
      }
      
      .radiant-flame-main.three {
        animation-duration: 2.1s;
        animation-delay: 3s;
      }
      
      @keyframes zoomIn {
        from { transform: scale(0) rotate(360deg); opacity: 0; }
        to { transform: scale(1) rotate(0deg); opacity: 1; }
      }
      

      
      html, body { 
        height: 100%; 
        margin: 0; 
        background: linear-gradient(135deg, #0a0014 0%, #1a0033 50%, #0a0014 100%);
        color: var(--text); 
        font-family: 'Orbitron', monospace;
        overflow: hidden;
        position: relative;
      }
      
      body::before {
        content: '';
        position: absolute;
        inset: 0;
        background: 
          radial-gradient(circle at 20% 50%, rgba(255,0,255,0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 50%, rgba(0,255,255,0.1) 0%, transparent 50%);
        animation: float 8s ease-in-out infinite;
        pointer-events: none;
      }
      
      .wrap { 
        position: relative; 
        width: 100vw; 
        height: 100vh; 
        display: grid; 
        place-items: center; 
      }
      
      canvas { 
        width: min(100vw, 1400px); 
        height: min(75vh, 900px); 
        max-width: 1400px; 
        max-height: 900px; 
        aspect-ratio: 14 / 9; 
        display: block; 
        border-radius: 20px; 
        border: 3px solid;
        border-image: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff) 1;
        animation: neonGlow 3s ease-in-out infinite;
        background: radial-gradient(ellipse at center, #1a0033 0%, #0a0014 100%);
      }
      
      .hud { 
        position: absolute; 
        top: 16px; 
        left: 50%; 
        transform: translateX(-50%); 
        width: min(1600px, 98vw); 
        display: grid; 
        grid-template-columns: 1fr auto; 
        gap: 10px; 
        align-items: center; 
        pointer-events: none; 
        z-index: 200;
      }
      
      .panel { 
        background: linear-gradient(135deg, rgba(255,0,255,0.1), rgba(0,255,255,0.1));
        border: 2px solid;
        border-image: linear-gradient(45deg, #ff00ff, #00ffff) 1;
        border-radius: 15px; 
        backdrop-filter: blur(10px); 
        box-shadow: 
          0 0 30px rgba(255,0,255,0.5),
          inset 0 0 20px rgba(0,255,255,0.2);
        animation: neonPulse 4s ease-in-out infinite;
      }
      
      .stats { 
        pointer-events: auto; 
        display: grid; 
        grid-auto-flow: column; 
        gap: 20px; 
        padding: 12px 16px; 
        font-size: 14px; 
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      
      .stats strong { 
        color: var(--neon-pink); 
        text-shadow: 0 0 10px currentColor;
      }
      
      .bar { 
        width: 240px; 
        height: 12px; 
        background: rgba(0,0,0,0.5); 
        border: 2px solid var(--neon-blue); 
        border-radius: 999px; 
        overflow: hidden; 
        box-shadow: inset 0 0 10px rgba(0,255,255,0.3);
        position: relative;
      }
      
      .bar > div { 
        height: 100%; 
        background: linear-gradient(90deg, #00ff00, #ffff00, #ff00ff);
        transform-origin: left center;
        box-shadow: 0 0 20px currentColor;
        position: relative;
      }
      
      .bar > div::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        animation: float 2s linear infinite;
      }
      
      .btns { 
        pointer-events: auto; 
        display: flex; 
        gap: 10px; 
        padding: 10px; 
      }
      
      button { 
        background: linear-gradient(135deg, #ff00ff, #8000ff);
        border: 2px solid var(--neon-pink);
        border-radius: 12px; 
        color: white; 
        padding: 10px 16px; 
        cursor: pointer; 
        font-weight: 900;
        font-family: 'Orbitron', monospace;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s;
        text-shadow: 0 0 10px rgba(255,255,255,0.5);
      }
      
      button::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
        border-radius: 12px;
        opacity: 0;
        z-index: -1;
        transition: opacity 0.3s;
      }
      
      button:hover::before {
        opacity: 1;
        animation: neonPulse 1s ease-in-out infinite;
      }
      
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(255,0,255,0.5);
      }
      
      button.primary { 
        background: linear-gradient(135deg, #00ffff, #0080ff);
        border-color: var(--neon-blue);
        animation: float 3s ease-in-out infinite;
      }
      
      button:disabled { 
        opacity: .5; 
        cursor: not-allowed;
        animation: none;
      }
      
      .overlay { 
        position: absolute; 
        inset: 0; 
        display: none; 
        place-items: center;
        background: radial-gradient(ellipse at center, rgba(0,0,0,0.8), rgba(0,0,0,0.95));
        z-index: 100;
      }
      
      .modal { 
        width: min(980px, 92vw); 
        max-height: min(660px, 78vh); 
        background: linear-gradient(135deg, #1a0033, #0a0014);
        border: 3px solid;
        border-image: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff) 1;
        border-radius: 20px; 
        display: grid; 
        grid-template-rows: auto 1fr auto; 
        box-shadow: 
          0 0 60px rgba(255,0,255,0.6),
          0 0 120px rgba(0,255,255,0.3),
          inset 0 0 60px rgba(255,0,255,0.1);
        pointer-events: auto;
        animation: zoomIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }
      
      .modal .head { 
        padding: 20px 24px; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        border-bottom: 2px solid rgba(255,0,255,0.3);
        background: linear-gradient(90deg, rgba(255,0,255,0.1), rgba(0,255,255,0.1));
      }
      
      .modal .head h2 { 
        margin: 0; 
        font-size: 32px; 
        font-weight: 900;
        background: linear-gradient(45deg, #ff00ff, #00ffff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: textGlow 2s ease-in-out infinite;
        text-transform: uppercase;
        letter-spacing: 3px;
      }
      
      .modal .body { 
        padding: 20px; 
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(280px,1fr)); 
        gap: 16px; 
        overflow: auto;
      }
      
      .modal .body::-webkit-scrollbar {
        width: 10px;
      }
      
      .modal .body::-webkit-scrollbar-track {
        background: rgba(0,0,0,0.5);
        border-radius: 10px;
      }
      
      .modal .body::-webkit-scrollbar-thumb {
        background: linear-gradient(45deg, #ff00ff, #00ffff);
        border-radius: 10px;
      }
      
      .card { 
        background: linear-gradient(135deg, rgba(255,0,255,0.1), rgba(0,255,255,0.05));
        border: 2px solid;
        border-image: linear-gradient(45deg, #ff00ff, #00ffff) 1;
        border-radius: 15px; 
        padding: 24px; 
        display: grid; 
        grid-template-columns: 1fr auto; 
        gap: 16px; 
        align-items: start;
        transition: all 0.3s;
        position: relative;
        overflow: hidden;
        min-height: 120px;
      }
      
      .card::before {
        content: '⚔️';
        position: absolute;
        right: 10px;
        top: 10px;
        font-size: 24px;
        opacity: 0.3;
        animation: float 3s ease-in-out infinite;
      }
      
      .card:hover {
        transform: translateY(-5px) scale(1.02);
        box-shadow: 0 10px 40px rgba(255,0,255,0.4);
        background: linear-gradient(135deg, rgba(255,0,255,0.2), rgba(0,255,255,0.1));
      }
      
      .card .title { 
        font-weight: 900;
        font-size: 18px;
        color: var(--neon-pink);
        text-shadow: 0 0 10px currentColor;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      
      .card .desc { 
        grid-column: 1 / -1; 
        color: var(--neon-blue);
        font-size: 14px;
        text-shadow: 0 0 5px currentColor;
      }
      
      .card .cost { 
        color: var(--gold);
        font-weight: 900;
        font-size: 20px;
        text-shadow: 0 0 15px currentColor;
      }
      
      .modal .foot { 
        padding: 16px 20px; 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        border-top: 2px solid rgba(0,255,255,0.3);
        background: linear-gradient(90deg, rgba(0,255,255,0.1), rgba(255,0,255,0.1));
      }
      
      .toast { 
        position: absolute; 
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        display: grid; 
        gap: 10px;
        z-index: 1000;
        pointer-events: none; /* Allow clicks to pass through */
        width: 100%;
        text-align: center;
      }
      
      .toast > div { 
        background: linear-gradient(135deg, #ff00ff, #8000ff);
        border: 2px solid var(--neon-pink);
        padding: 7px 10px; 
        border-radius: 8px;
        color: white;
        font-weight: 700;
        font-size: 0.6em;
        text-transform: uppercase;
        animation: toastIn 0.3s ease-out;
        box-shadow: 0 0 30px rgba(255,0,255,0.6);
        transform-origin: center;
        text-align: center;
      }
      
      .intel-box {
        position: absolute;
        top: -200px;
        left: 50%;
        transform: translateX(-50%);
        width: 90vw;
        height: 240px;
        background: linear-gradient(135deg, rgba(255,0,255,0.15), rgba(0,255,255,0.1));
        border: 2px solid;
        border-image: linear-gradient(45deg, #ff00ff, #00ffff) 1;
        border-radius: 15px;
        padding: 15px 20px;
        z-index: 150;
        transition: top 0.5s ease-in-out;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 40px rgba(255,0,255,0.4);
      }
      
      .intel-box.show {
        top: 90px;
      }
      
      .intel-title {
        color: #ff00ff;
        text-shadow: 0 0 10px #ff00ff;
        font-size: 18px;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 15px;
        text-align: center;
      }
      
      .intel-content {
        display: flex;
        gap: 20px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }
      
      .intel-enemy {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: rgba(0,0,0,0.3);
        border-radius: 10px;
        border: 1px solid rgba(255,0,255,0.3);
        min-width: 200px;
      }
      
      .intel-enemy canvas {
        width: 50px;
        height: 50px;
        border: 2px solid;
        border-radius: 8px;
        background: rgba(0,0,0,0.5);
      }
      
      .intel-enemy-info {
        flex: 1;
      }
      
      .intel-enemy-name {
        color: #ffffff;
        font-weight: bold;
        font-size: 14px;
        margin-bottom: 4px;
      }
      
      .intel-enemy-desc {
        color: #8ff;
        font-size: 12px;
        line-height: 1.3;
      }
      
      .intel-enemy-count {
        color: #ffffff;
        font-weight: bold;
        font-size: 16px;
        text-align: center;
        min-width: 40px;
      }
      
      .pill {
        background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(255,0,255,0.2));
        border: 1px solid var(--neon-blue);
        padding: 4px 8px;
        border-radius: 999px;
        font-weight: 700;
        font-size: 11px;
        text-shadow: 0 0 5px currentColor;
        white-space: nowrap; /* avoid wrapping Lv 0 */
        font-feature-settings: 'zero' 0; /* avoid slashed zero rendering */
        min-width: fit-content;
        display: inline-block;
      }
      
      /* Epic Title Screen */
      .epic-title {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
        background-size: 300% 300%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: textGlow 2s ease-in-out infinite, gradientShift 3s ease-in-out infinite;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 4px;
        margin: 20px 0;
      }
      
      @keyframes gradientShift {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
      }
      
      @keyframes textGlow {
        0%, 100% { text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px #ffffff; }
        50% { text-shadow: 0 0 15px #ffffff, 0 0 25px #ffffff, 0 0 35px #ffffff; }
      }
      
      .subtitle {
        text-align: center;
        color: var(--neon-blue);
        text-shadow: 0 0 10px currentColor;
        font-size: 16px;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 30px;
      }
      
      /* Achievement popup */
      .achievement {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff00ff, #00ffff);
        padding: 20px 40px;
        border-radius: 20px;
        color: white;
        font-size: 24px;
        font-weight: 900;
        text-transform: uppercase;
        animation: zoomIn 0.5s ease-out;
        box-shadow: 0 0 60px rgba(255,0,255,0.8);
        z-index: 1000;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <canvas id="game" width="1400" height="900"></canvas>
      <div class="hud">
        <div class="panel stats">
          <div>⚔️ <strong>Wave</strong>: <span id="uiWave">1</span></div>
          <div>💰 <strong>Gold</strong>: <span id="uiGold">0</span>g</div>
          <div id="uiInterest" style="display: none;">💎 <strong>Interest</strong>: <span id="uiInterestValue">0</span>g</div>
          <div class="bar"><div id="uiHpBar"></div></div>
          <div>🏰 <strong>Castle</strong>: <span id="uiHpText">100/100</span></div>

          <div>⭐ <strong>Score</strong>: <span id="uiScore">0</span> · <span id="uiCombo">x1</span></div>
          <div>👑 High: <span id="uiHigh">0</span></div>
        </div>
        <div class="panel btns">
          <button id="btnPause">⏸️ Pause</button>
          <button id="btnReset">🔄 Reset</button>
        </div>
      </div>
      <div id="overlay" class="overlay">
        <div class="modal">
          <div class="head">
            <div>
              <h2 id="ovTitle">Neon Knights</h2>
              <div id="ovSub" class="subtitle">Defend the realm with style</div>
            </div>

          </div>
          <div id="ovBody" class="body"></div>
          <div class="foot">
            <div id="ovTips" style="color: var(--neon-blue); text-shadow: 0 0 5px currentColor;"></div>
            <div>
              <button id="btnContinue" class="primary">⚔️ Battle!</button>
            </div>
          </div>
        </div>
      </div>
      <div id="toast" class="toast"></div>
      <div id="intelBox" class="intel-box" style="display: none;">
        <div class="intel-title">⚔️ NEXT WAVE</div>
        <div class="intel-content"></div>
      </div>
    </div>

    <script>
      'use strict';

      // ============================
      // Core Config
      // ============================
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const W = canvas.width, H = canvas.height;
      const CENTER = { x: W/2, y: H/2 + 40 };
      const CASTLE = { r: 140, maxHpBase: 100 };

      const STATE = { MENU: 'MENU', PLAY: 'PLAY', UPGRADE: 'UPGRADE', PAUSE: 'PAUSE', OVER: 'OVER' };
      const DIFFICULTY = { ENEMY_HP_MULT: 0.3 }; // 30% of original HP (reduce by 70%)

      // ============================
      // Utils
      // ============================
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const rand = (a,b) => Math.random() * (b - a) + a;
      const randInt = (a,b) => Math.floor(rand(a,b+1));

      class V2 {
        constructor(x=0,y=0){ this.x=x; this.y=y; }
        copy(){ return new V2(this.x,this.y); }
        add(v){ this.x+=v.x; this.y+=v.y; return this; }
        sub(v){ this.x-=v.x; this.y-=v.y; return this; }
        scale(s){ this.x*=s; this.y*=s; return this; }
        len(){ return Math.hypot(this.x,this.y); }
        norm(){ const l=this.len()||1; this.x/=l; this.y/=l; return this; }
        static sub(a,b){ return new V2(a.x-b.x,a.y-b.y); }
        static fromAngle(a, len=1){ return new V2(Math.cos(a)*len, Math.sin(a)*len); }
      }

      // ============================
      // Audio (Web Audio with pitch variance)
      // ============================
      const AudioBus = { ctx:null, master:null, ui:null, sfx:null };
      function initAudio(){ if(!AudioBus.ctx){ const AC = window.AudioContext||window.webkitAudioContext; if(AC){ const ctx=new AC(); AudioBus.ctx=ctx; const m=ctx.createGain();m.gain.value=0.7;m.connect(ctx.destination); AudioBus.master=m; const ui=ctx.createGain();ui.gain.value=0.8;ui.connect(m); AudioBus.ui=ui; const sfx=ctx.createGain();sfx.gain.value=1.0;sfx.connect(m); AudioBus.sfx=sfx; } } }
      function tone(bus, freq=440, dur=0.06, type='square', gain=0.05){ if(!AudioBus.ctx) return; const ctx=AudioBus.ctx; const osc=ctx.createOscillator(); const g=ctx.createGain(); osc.type=type; osc.frequency.value=freq*(0.92+Math.random()*0.16); g.gain.value=gain; osc.connect(g).connect(AudioBus[bus]||AudioBus.master); const t=ctx.currentTime; osc.start(t); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); osc.stop(t+dur+0.01); }
      const sfx = { 
        shoot:()=>tone('sfx', 980, 0.05, 'sawtooth', 0.06), 
        hit:()=>tone('sfx', 620, 0.05, 'sine', 0.07), 
        death:()=>tone('sfx', 200, 0.1, 'square', 0.08), 
        coin:()=>tone('sfx', 1200, 0.05, 'triangle', 0.05), 
        ui:()=>tone('ui', 520, 0.04, 'sine', 0.05),
        powerup:()=>tone('sfx', 1400, 0.08, 'sawtooth', 0.06),
        timeSlow:()=>tone('sfx', 300, 0.1, 'sine', 0.04)
      };

      // ============================
      // Input
      // ============================
      const mouse = { x:0, y:0, down:false, rdown:false };
      canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width/r.width); mouse.y = (e.clientY - r.top) * (canvas.height/r.height); });
      canvas.addEventListener('mousedown', (e)=>{ initAudio(); if(e.button===2){ mouse.rdown=true; } else { mouse.down=true; sfx.ui(); } });
      canvas.addEventListener('mouseup', (e)=>{ if(e.button===2){ mouse.rdown=false; } else { mouse.down=false; } });
      canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
      canvas.addEventListener('touchstart', e=>{ initAudio(); const t=e.touches[0]; const r=canvas.getBoundingClientRect(); mouse.x=(t.clientX-r.left)*(canvas.width/r.width); mouse.y=(t.clientY-r.top)*(canvas.height/r.height); mouse.down=true; sfx.ui(); e.preventDefault(); }, { passive:false });
      canvas.addEventListener('touchmove', e=>{ const t=e.touches[0]; const r=canvas.getBoundingClientRect(); mouse.x=(t.clientX-r.left)*(canvas.width/r.width); mouse.y=(t.clientY-r.top)*(canvas.height/r.height); e.preventDefault(); }, { passive:false });
      canvas.addEventListener('touchend', ()=>{ mouse.down=false; });
      const KEYS = new Set();
      window.addEventListener('keydown', e=>{ if(e.key==='Escape'){ togglePause(); } KEYS.add(e.key.toLowerCase()); });
      window.addEventListener('keyup', e=>{ KEYS.delete(e.key.toLowerCase()); });

      // ============================
      // Game Data
      // ============================
      const ui = { wave: byId('uiWave'), gold: byId('uiGold'), hpbar: byId('uiHpBar'), hptext: byId('uiHpText'), score: byId('uiScore'), combo: byId('uiCombo'), high: byId('uiHigh'), overlay: byId('overlay'), ovTitle: byId('ovTitle'), ovSub: byId('ovSub'), ovBody: byId('ovBody'), btnPause: byId('btnPause'), btnReset: byId('btnReset'), btnContinue: byId('btnContinue'), toast: byId('toast'), interest: byId('uiInterest'), interestValue: byId('uiInterestValue') };

      const SAVE_KEY = 'neon-knights-save-v1';
              function defaultUpgrades(){ return { multishot:0, piercing:0, explosive:0, rapid:0, crit:0, ballista:0, oil:0, treasury:0, fort:0, sniper:0, poison:0, cavalry:0, boomerang:0, necromancy:0, flamecannon:0, homingstrike:0, divineaegis:0, angelicknights:0, midasknights:0, radiantaegis:0 }; }
      const game = {
        state: STATE.MENU,
        last: performance.now(),
        dt: 0,
        wave: 1,
        score: 0,
        high: 0,
        gold: 100,
        castleHp: CASTLE.maxHpBase,
        castleMax: CASTLE.maxHpBase,
        enemies: [],
        projectiles: [],
        eProjectiles: [],
        particles: [],
        texts: [],
        coins: [],
        combo: 1,
        comboTimer: 0,
        stamina: 1,
        upgrades: defaultUpgrades(),
        nextWave: [],
        shake: 0,
        player: { wall: 0, x: CENTER.x, y: CENTER.y - CASTLE.r + 8, rate: 0.36, angle: 0 },
        bgPulse: 0,
        turretAngles: [0, 0, 0, 0], // Track current turret angles for smooth rotation
        cavalryTimer: 0, // Cavalry charge cooldown
        divineAegis: {
          active: false,
          hp: 0,
          maxHp: 0,
          respawnTimer: 0,
          size: 0,
          angle: 0,
          divineAegisAngle: 0 // Adjustable rotation angle for shield orientation
        }, // Divine Aegis shield
        battleMessage: {
          text: '',
          timer: 0,
          color: '#ffffff'
        }, // Battle message system
        treasuryInterest: 0, // Interest accumulated from King's Treasury
        undeadDragon: {
          active: false,
          x: CENTER.x,
          y: CENTER.y,
          hp: 0,
          maxHp: 0,
          damage: 0,
          kills: 0,
          flameLevel: 0,
          lastFlameTime: 0
        }, // Undead Dragon companion
        dragonkinLord: false, // Whether Dragonkin Lord ability is purchased
      };

      // Save/Load
      (function initSave(){ const raw = localStorage.getItem(SAVE_KEY); if(raw){ try{ const s=JSON.parse(raw); game.high=s.high||0; game.upgrades=Object.assign(defaultUpgrades(), s.upgrades||{}); }catch{} } updateHUD(); })();
      function persist(){ try{ localStorage.setItem(SAVE_KEY, JSON.stringify({ high: game.high, upgrades: game.upgrades })); }catch{} }

      // ============================
      // Entities
      // ============================
      function spawnText(x,y,text,color='#fff',life=0.8,size=16,italic=false){ game.texts.push({ x, y, vy: -30, text, color, life, total:life, size, italic }); }
      function spawnParticles(x,y,color,count=16,spread=1){ for(let i=0;i<count;i++){ game.particles.push({ x, y, vx: rand(-120,120)*spread, vy: rand(-140,0)*spread, life: rand(0.4,0.8), color, size: rand(2,5), glow: true }); } }
      function spawnCoins(x,y,count=6){ for(let i=0;i<count;i++){ game.coins.push({ x, y, vx: rand(-110,110), vy: rand(-160,-60), life: 1.2, size: rand(3,5), rot: rand(0, Math.PI*2) }); } }

      // Enemies - Medieval Themed
      function enemySpawnEdge(){ const edge = randInt(0,3); const M = 60; if(edge===0) return { x: rand(M,W-M), y: -M, side:'N' }; if(edge===1) return { x: W+M, y: rand(M,H-M), side:'E' }; if(edge===2) return { x: rand(M,W-M), y: H+M, side:'S' }; return { x: -M, y: rand(M,H-M), side:'W' }; }

      function makeEnemy(type, hpScale=1){
        const p = enemySpawnEdge();
        const base = ENEMY[type];
        const hp = Math.round(base.hp * hpScale * DIFFICULTY.ENEMY_HP_MULT);
        return { type, x:p.x, y:p.y, side:p.side, vx:0, vy:0, speed: base.speed, radius: base.radius, hp, maxHp: hp, damage: base.damage, reward: base.reward, heading: Math.atan2(CENTER.y-p.y, CENTER.x-p.x), blockAngle: base.blockAngle||0, healTimer: 0, split: base.split||0, dead:false, color: base.color, wobble: rand(0,Math.PI*2), invisible: base.invisible||false, flyer: base.flyer||false, necro: base.necro||false, bomber: base.bomber||false, glowColor: base.glowColor } 
      }
      
      function spawnCavalry(x = game.player.x, y = game.player.y){
        // Check if Angelic Knights or Midas Knights upgrade is active
        const angelicLevel = game.upgrades.angelicknights || 0;
        const midasLevel = game.upgrades.midasknights || 0;
        const isAngelic = angelicLevel > 0;
        const isMidas = midasLevel > 0;
        const isGoldenAngelic = isAngelic && isMidas; // Both upgrades purchased
        
        // Calculate gold-based bonuses for Midas Knights (only for midas or golden angelic)
        const shouldGetGoldBonus = isMidas || isGoldenAngelic;
        const goldMultiplier = shouldGetGoldBonus ? Math.min(5, Math.max(1, Math.floor(game.gold / 100))) : 1; // +1 per 100 gold, max +5
        const goldBonus = shouldGetGoldBonus ? (goldMultiplier - 1) * 0.5 : 0; // +50% per gold tier
        
        // Spawn a friendly knight at the specified position
        const cavalry = {
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          speed: 80 * (1 + goldBonus), // Fast movement with gold bonus
          radius: 16,
          hp: 100 * (1 + goldBonus),
          maxHp: 100 * (1 + goldBonus),
          damage: 15 * (1 + goldBonus),
          heading: 0,
          dead: false,
          color: isGoldenAngelic ? '#ffd700' : isAngelic ? '#000000' : isMidas ? '#ffd700' : '#00ff88', // Golden for golden angelic, black for angelic, gold for midas, green for regular
          glowColor: isGoldenAngelic ? '#ffd700' : isAngelic ? '#ffffff' : isMidas ? '#ffd700' : '#00ff88', // Golden glow for golden angelic, white glow for angelic, gold for midas
          type: isGoldenAngelic ? 'goldenangelic' : isAngelic ? 'angelic' : isMidas ? 'midas' : 'cavalry',
          target: null,
          life: isGoldenAngelic ? (10.0 + angelicLevel * 2.0 + midasLevel * 1.0) : isAngelic ? (10.0 + angelicLevel * 2.0) : isMidas ? (10.0 + midasLevel * 1.0) : 10.0, // Combined bonuses for golden angelic
          wobble: rand(0, Math.PI*2),
          angelic: isAngelic || isGoldenAngelic, // Mark as angelic for healing logic
          midas: isMidas || isGoldenAngelic, // Mark as midas for gold bonus logic
          goldenAngelic: isGoldenAngelic, // Mark as golden angelic for special rendering
          goldMultiplier: shouldGetGoldBonus ? goldMultiplier : 1, // Store gold multiplier for kill rewards
          taunt: true // Knights have taunt ability to draw enemy attention
        };
        
        game.enemies.push(cavalry); // Add to enemies array for easy management
        const spawnColor = isGoldenAngelic ? '#ffd700' : isAngelic ? '#ffffff' : isMidas ? '#ffd700' : '#00ff88';
        spawnParticles(cavalry.x, cavalry.y, spawnColor, 20, 1.0);
        const message = isGoldenAngelic ? '👼💰 GOLDEN ANGELIC KNIGHTS!' : isAngelic ? '👼 ANGELIC KNIGHTS!' : isMidas ? '💰 MIDAS KNIGHTS!' : '⚔️ CAVALRY CHARGE!';
        const messageColor = isGoldenAngelic ? '#ffd700' : isAngelic ? '#ffffff' : isMidas ? '#ffd700' : '#00ff88';
        setBattleMessage(message, 2.0, messageColor);
      }

      const ENEMY = {
        squire:  { hp: 50, speed: 45, damage: 5, reward: 8, radius: 16, color: '#ff00ff', glowColor: '#ff00ff', name: 'Squire' },
        knight:  { hp: 80, speed: 35, damage: 6, reward: 12, radius: 18, color: '#00ffff', glowColor: '#00ffff', blockAngle: Math.PI*0.55, name: 'Knight' },
        rogue:   { hp: 40, speed: 50, damage: 8, reward: 14, radius: 14, color: '#bf00ff', glowColor: '#bf00ff', invisible:true, name: 'Rogue' },
        lancer:  { hp: 70, speed: 32, damage: 5, reward: 16, radius: 16, color: '#ffff00', glowColor: '#ffff00', bomber:true, name: 'Lancer' },
        pegasus: { hp: 50, speed: 48, damage: 7, reward: 12, radius: 14, color: '#00ff88', glowColor: '#00ff88', flyer:true, name: 'Pegasus' },
        cleric:  { hp: 65, speed: 38, damage: 5, reward: 12, radius: 15, color: '#88ff00', glowColor: '#88ff00', name: 'Cleric' },
        wizard:  { hp: 85, speed: 30, damage: 5, reward: 18, radius: 18, color: '#ff88ff', glowColor: '#ff88ff', necro:true, name: 'Wizard' },
        jester:  { hp: 70, speed: 40, damage: 5, reward: 10, radius: 16, color: '#ff8800', glowColor: '#ff8800', split: 2, name: 'Jester' },
        page:    { hp: 25, speed: 52, damage: 3, reward: 3, radius: 12, color: '#ffff88', glowColor: '#ffff88', name: 'Page' },
        dragon:  { hp: 6600, speed: 25, damage: 18, reward: 80, radius: 26, color: '#ff0088', glowColor: '#ff0088', name: 'DRAGON' },
        golem:   { hp: 12000, speed: 8, damage: 35, reward: 100, radius: 40, color: '#8B4513', glowColor: '#8B4513', name: 'GOLEM' },
      };

      // Projectiles
      function makeProjectile(x,y,dir,stats){ 
        let speed = 540*(1+0.25*game.upgrades.rapid); 
        let pierce = game.upgrades.piercing>0 ? 1+game.upgrades.piercing : 0;
        let baseDmg = 18*(1+0.35*game.upgrades.crit);
        
        // Calculate distance to screen edge to ensure projectiles reach the edge
        const cosDir = Math.cos(dir);
        const sinDir = Math.sin(dir);
        
        // Calculate distance to each screen edge
        let distToEdge = Infinity;
        if(cosDir > 0) distToEdge = Math.min(distToEdge, (W - x) / cosDir);
        if(cosDir < 0) distToEdge = Math.min(distToEdge, (0 - x) / cosDir);
        if(sinDir > 0) distToEdge = Math.min(distToEdge, (H - y) / sinDir);
        if(sinDir < 0) distToEdge = Math.min(distToEdge, (0 - y) / sinDir);
        
        // Add some buffer to ensure it goes off screen
        distToEdge = Math.max(distToEdge, 0) + 50;
        
        // Calculate life based on distance and speed
        let baseLife = distToEdge / speed;
        
        // Check for time slow sniper first (takes priority over regular sniper upgrade)
        const isTimeSlow = game.dtScale < 1; // Check if time slow is active
        if(isTimeSlow) {
          // Create instant line effect for time slow sniper shots
          createSniperLine(x, y, dir, baseDmg * 2, true);
          return null; // Return null to indicate no projectile should be created
        }
        
        // Regular sniper upgrade - instant line shot mechanics
        if(game.upgrades.sniper > 0) {
          // Create instant line effect instead of projectile
          createSniperLine(x, y, dir, baseDmg * 3, false);
          return null; // Return null to indicate no projectile should be created
        }
        
        // Flame Cannon upgrade - constant fire stream
        if(game.upgrades.flamecannon > 0) {
          createFlameStream(x, y, dir);
          return null; // Return null to indicate no projectile should be created
        }
        
        // Homing Strike upgrade - seeking projectile that speeds up
        if(game.upgrades.homingstrike > 0) {
          createHomingStrike(x, y, dir);
          return null; // Return null to indicate no projectile should be created
        }
        
        const vx = Math.cos(dir)*speed, vy = Math.sin(dir)*speed; 
        
        // Boomerang upgrade - large projectile that returns
        const boomerangLevel = game.upgrades.boomerang || 0;
        const isBoomerang = boomerangLevel > 0;
        const boomerangSize = isBoomerang ? 6 + boomerangLevel * 2 : 3; // +2 size per level
        const boomerangDamage = isBoomerang ? baseDmg * (1 + boomerangLevel * 0.85) : baseDmg; // +85% damage per level (increased from 50%)
        
        return { 
          x, y, vx, vy, 
          life: baseLife, 
          size: boomerangSize, 
          trail: [], 
          pierce: pierce, 
          explosive: game.upgrades.explosive>0, 
          baseDmg: boomerangDamage, 
          crit: game.upgrades.crit>0, 
          hitSet:new Set(), 
          color: isTimeSlow ? '#ffff00' : (isBoomerang ? '#ff8800' : '#00ffff'), // Orange for boomerang
          poison: game.upgrades.poison>0, // Add poison property
          timeSlow: isTimeSlow, // Mark as time slow projectile
          sniper: false, // No longer a sniper projectile
          boomerang: isBoomerang, // Mark as boomerang projectile
          originX: x, // Store origin for return path
          originY: y,
          returnPhase: false // Track if projectile is returning
        }; 
      }
      
      function createSniperLine(x, y, dir, damage, isTimeSlow = false) {
        // Create a line that extends from the player to the edge of the screen
        const lineLength = Math.max(W, H) * 2; // Long enough to reach screen edge
        const endX = x + Math.cos(dir) * lineLength;
        const endY = y + Math.sin(dir) * lineLength;
        
        // Sniper upgrade increases damage and width
        const sniperLevel = game.upgrades.sniper || 0;
        const waveScaling = 1 + (game.wave - 1) * 0.15; // +15% damage per wave
        const finalDamage = damage * (1 + sniperLevel * 0.5) * waveScaling; // +50% damage per level + wave scaling
        const lineWidth = 6 + sniperLevel * 2; // +2 pixels width per level
        
        // Add line to game state for rendering
        if(!game.sniperLines) game.sniperLines = [];
        game.sniperLines.push({
          x1: x, y1: y, x2: endX, y2: endY,
          life: 0.3, // Fade out quickly
          damage: finalDamage,
          isTimeSlow: isTimeSlow,
          width: lineWidth
        });
        
        // Orbital Strike - trigger orbital strike for sniper shots
        if(game.upgrades.orbitalstrike > 0) {
          const orbitalLevel = game.upgrades.orbitalstrike;
          const strikeDelay = 0.5; // 0.5 second delay
          const baseRadius = 120 + orbitalLevel * 30; // Base 120 + 30 per level
          const baseDamage = 50 + orbitalLevel * 25; // Base 50 + 25 per level
          
          // Calculate strike position (at mouse position instead of end of line)
          const strikeX = mouse.x;
          const strikeY = mouse.y;
          
          // Add orbital strike to game state
          if(!game.orbitalStrikes) game.orbitalStrikes = [];
          game.orbitalStrikes.push({
            x: strikeX,
            y: strikeY,
            radius: baseRadius,
            damage: baseDamage,
            timer: strikeDelay,
            totalDelay: strikeDelay,
            level: orbitalLevel
          });
          
          // Visual warning effect
          spawnText(strikeX, strikeY-50, 'ORBITAL STRIKE INCOMING!', '#ff0000', 2.0, 20);
          spawnParticles(strikeX, strikeY, '#ff0000', 20, 1.0);
        }
        
        // Damage all enemies in the line's path
        for(const e of game.enemies) {
                    if(e.dead) continue; 
          if(e.invisible) continue; // Invisible enemies are always invisible now
          if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue; // All friendly units are immune to sniper damage
          
          // Check if enemy is close to the line
          const dist = distanceToLine(e.x, e.y, x, y, endX, endY);
          const hitRadius = e.radius + 5 + (lineWidth - 6) * 0.5; // Wider lines hit more easily
          if(dist < hitRadius) {
            // Instant kill shields
            if(e.type === 'knight' && (e.shieldHp == null || e.shieldHp > 0)) {
              e.shieldHp = 0;
              spawnText(e.x, e.y-e.radius-15, 'SHIELD BROKEN!', '#ff0000', 1.0, 18);
            }
            
            // Apply damage
            e.hp -= finalDamage;
            const damageColor = isTimeSlow ? '#ffff00' : '#ff00ff';
            spawnText(e.x, e.y-12, `-${Math.round(finalDamage)}`, damageColor, 0.6, 24);
            spawnParticles(e.x, e.y, e.glowColor, 15, 0.8);
            
            // Dragonkin Lord - execute dragons with time slow sniper shots
            if(isTimeSlow && e.type === 'dragon' && e.hp <= e.maxHp * 0.2 && game.dragonkinLord && !game.undeadDragon.active) {
              // Execute the dragon and recruit it as Undead Dragon
              e.dead = true;
              
              // Initialize Undead Dragon
              game.undeadDragon.active = true;
              game.undeadDragon.x = e.x;
              game.undeadDragon.y = e.y;
              game.undeadDragon.maxHp = 8000; // Base health
              game.undeadDragon.hp = game.undeadDragon.maxHp;
              game.undeadDragon.damage = 25; // Base damage
              game.undeadDragon.kills = 0;
              game.undeadDragon.flameLevel = 1;
              game.undeadDragon.lastFlameTime = 0;
              
              spawnText(e.x, e.y-e.radius-30, 'EXECUTED!', '#ffd700', 2.0, 24);
              spawnParticles(e.x, e.y, '#ffd700', 60, 2.0);
              setBattleMessage('🐉 UNDEAD DRAGON RECRUITED!', 4.0, '#ffd700');
              showAchievement('DRAGON EXECUTION!');
            }
            
            // Time Necromancy - convert enemies killed by time slow sniper shots
            if(isTimeSlow && e.hp <= 0 && game.upgrades.necromancy > 0) {
              const necroLevel = game.upgrades.necromancy;
              const statBonus = 1 + necroLevel * 0.25; // +25% stats per level
              
              // Convert the enemy to friendly
              e.dead = false;
              e.maxHp = e.maxHp * statBonus;
              e.hp = e.maxHp; // Set to 100% health after conversion
              e.damage = e.damage * statBonus;
              e.speed = e.speed * 1.6; // +60% speed
              e.originalType = e.type; // Store original type before changing
              e.type = 'converted';
              e.color = '#00ff88';
              e.glowColor = '#00ff88';
              e.invisible = false; // Ensure they are visible
              
              spawnText(e.x, e.y-e.radius-25, 'CONVERTED!', '#00ff88', 1.0, 20);
              spawnParticles(e.x, e.y, '#00ff88', 30, 1.0);
              setBattleMessage('💀 ENEMY CONVERTED!', 2.5, '#00ff88');
            }
            
            // Apply poison if active
            if(game.upgrades.poison > 0) {
              if(!e.poisonStacks) e.poisonStacks = 0;
              e.poisonStacks = e.poisonStacks + 1; // Infinite stacking
              e.poisonTimer = 0;
              spawnParticles(e.x, e.y, '#00ff00', 6, 0.4);
            }
            
            sfx.hit();
            game.shake = Math.min(12, game.shake + 3);
          }
        }
      }
      
      function createFlameStream(x, y, dir) {
        const flameLevel = game.upgrades.flamecannon;
        const baseRange = 80; // Increased for more triangular shape
        const baseWidth = 40; // Narrower base for more triangular shape
        const range = baseRange * (1 + flameLevel * 0.15); // +15% range per level
        const width = baseWidth * (1 + flameLevel * 0.15); // +15% width per level
        const baseDamage = 1 + flameLevel; // +1 base damage per level
        const stackMultiplier = 5 + flameLevel; // +1 stack multiplier per level
        
        // Calculate cone-shaped flame area (more triangular)
        const endX = x + Math.cos(dir) * range;
        const endY = y + Math.sin(dir) * range;
        
        // Add flame stream to game state for rendering
        if(!game.flameStreams) game.flameStreams = [];
        game.flameStreams.push({
          x1: x, y1: y, x2: endX, y2: endY,
          width: width,
          life: 0.3, // Short duration
          baseDamage: baseDamage,
          stackMultiplier: stackMultiplier,
          dir: dir, // Store direction for cone calculation
          range: range // Store range for cone calculation
        });
        
        // Create sputtering projectiles
        for(let i = 0; i < 3; i++) { // 3 sputtering projectiles
          const sputterAngle = dir + (Math.random() - 0.5) * 0.4; // Slightly wider spread
          const sputterSpeed = 250 + Math.random() * 150; // Faster sputters
          const sputterX = endX; // Start exactly from the tip of the flame cone
          const sputterY = endY;
          
          if(!game.projectiles) game.projectiles = [];
          game.projectiles.push({
            x: sputterX,
            y: sputterY,
            vx: Math.cos(sputterAngle) * sputterSpeed,
            vy: Math.sin(sputterAngle) * sputterSpeed,
            size: 4,
            life: 1.2, // Slightly longer life
            baseDmg: 5, // Small damage
            color: '#ff0000',
            src: 'flamecannon',
            sputter: true, // Mark as sputtering projectile
            burnStacks: 1, // Apply 1 burn stack per sputter
            trail: [] // Empty trail to prevent errors
          });
        }
        
        // Damage all enemies in the flame area
        for(const e of game.enemies) {
          if(e.dead) continue;
          if(e.invisible) continue; // Invisible enemies are always invisible now
          if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue; // Don't damage friendly units
          
          // Check if enemy is in the cone-shaped flame area
          const distToLine = distanceToLine(e.x, e.y, x, y, endX, endY);
          const distFromStart = Math.sqrt((e.x - x) * (e.x - x) + (e.y - y) * (e.y - y));
          
          // More triangular cone shape: width increases linearly with distance
          const coneWidth = width * (distFromStart / range);
          const hitRadius = e.radius + coneWidth * 0.5;
          
          // Check if enemy is within the cone and not behind the flame source
          if(distToLine < hitRadius && distFromStart <= range && distFromStart > 0) {
            // Apply immediate flamethrower damage (20 + level bonus)
            const immediateDamage = 20 + flameLevel;
            e.hp -= immediateDamage;
            spawnText(e.x, e.y-25, `-${immediateDamage}`, '#ff0000', 0.8, 18);
            
            // Apply fire damage stacks (1 stack per 0.3 seconds)
            if(!e.fireStacks) e.fireStacks = 0;
            e.fireStacks += 1; // Add 1 stack per hit
            e.fireTimer = 0.3; // Start timer immediately so damage ticks right away
            
            // Visual effect
            spawnParticles(e.x, e.y, '#ff4400', 8, 0.6);
            spawnText(e.x, e.y-12, `+1`, '#ff4400', 0.6, 16);
          }
        }
      }
      
      function createHomingStrike(x, y, dir) {
        const homingLevel = game.upgrades.homingstrike;
        const baseSpeed = 200; // Slow initial speed
        const baseDamage = 25 + homingLevel * 6; // Base 25 + 6 per level
        const baseRadius = 60 + homingLevel * 15; // Base 60 + 15 per level
        const maxSpeed = 800 + homingLevel * 200; // Max speed increases with level
        const acceleration = 300 + homingLevel * 100; // Acceleration increases with level
        
        // Create homing projectile
        if(!game.projectiles) game.projectiles = [];
        game.projectiles.push({
          x: x,
          y: y,
          vx: Math.cos(dir) * baseSpeed,
          vy: Math.sin(dir) * baseSpeed,
          size: 5,
          life: 4.0, // Long life for seeking
          baseDmg: baseDamage,
          color: '#ff00ff',
          src: 'homingstrike',
          homing: true, // Mark as homing projectile
          currentSpeed: baseSpeed,
          maxSpeed: maxSpeed,
          acceleration: acceleration,
          explosionRadius: baseRadius,
          target: null, // Will be set during update
          trail: []
        });
        
        setBattleMessage('🎯 HOMING STRIKE!', 1.5, '#ff00ff');
      }
      
      function distanceToLine(px, py, x1, y1, x2, y2) {
        // Calculate distance from point (px,py) to line segment (x1,y1) to (x2,y2)
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        
        if(lenSq !== 0) param = dot / lenSq;
        
        let xx, yy;
        if(param < 0) {
          xx = x1;
          yy = y1;
        } else if(param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // ============================
      // Game Flow
      // ============================
      function startGame(){ 
        game.state = STATE.PLAY; 
        game.wave=1; 
        game.gold=100; 
        game.score=0; 
        game.castleMax = CASTLE.maxHpBase; 
        CASTLE.r = 140; 
        game.upgrades = defaultUpgrades(); 
        applyFortifications(); 
        game.castleHp = game.castleMax; 
        game.enemies.length=0; 
        game.projectiles.length=0; 
        game.eProjectiles.length=0; 
        game.particles.length=0; 
        game.texts.length=0; 
        game.coins.length=0; 
        game.player.wall=0; 
        game._endQueued=false; 
        game._spawnedAny=false; 
        game.turretAngles = [0, 0, 0, 0];
        game.cavalryTimer = 0;
        game.sniperReloadTimer = 0;
        game.sniperLines = [];
        game.flameStreams = [];
        game.homingProjectiles = [];
        game.orbitalStrikes = [];
        game.lightningBolts = [];
        // Reset Dragonkin Lord and Undead Dragon for new game
        game.dragonkinLord = false;
        game.undeadDragon = {
          active: false,
          x: CENTER.x,
          y: CENTER.y,
          hp: 0,
          maxHp: 0,
          damage: 0,
          kills: 0,
          flameLevel: 0,
          lastFlameTime: 0
        };
        // Initialize Divine Aegis
        if(game.upgrades.divineaegis > 0) {
          const level = game.upgrades.divineaegis;
          const radiantLevel = game.upgrades.radiantaegis || 0;
          game.divineAegis.active = true;
          game.divineAegis.maxHp = 100 + level * 25; // Base 100 + 25 per level
          game.divineAegis.hp = game.divineAegis.maxHp;
          // Size scales with both Divine Aegis and Radiant Aegis levels
          game.divineAegis.size = 48 + level * 12 + radiantLevel * 8; // Base 48 + 12 per level + 8 per radiant level
          game.divineAegis.respawnTimer = 0;

        }
        updatePlayerPos(); 
        planAndStartWave(); 
        game.last=performance.now(); 
        requestAnimationFrame(loop); 
        
        // Hide intel box when game starts
        const intelBox = document.getElementById('intelBox');
        if(intelBox) {
          intelBox.style.display = 'none';
          intelBox.style.top = '-200px';
        }
      }
      function endWave(){ 
        // Calculate gold from converted units before removing them
        let convertedGold = 0;
        const convertedUnits = game.enemies.filter(e => e.type === 'converted');
        for(const unit of convertedUnits) {
          // Calculate gold based on original enemy type
          if(unit.originalType && ENEMY[unit.originalType]) {
            let baseReward = ENEMY[unit.originalType].reward;
            // Apply Midas Knights bonus if applicable
            if(game.upgrades.midasknights > 0) {
              const midasLevel = game.upgrades.midasknights;
              baseReward *= (1 + midasLevel * 0.5); // +50% per level
            }
            // Apply King's Treasury bonus if applicable
            if(game.upgrades.treasury > 0) {
              const treasuryLevel = game.upgrades.treasury;
              baseReward *= (1 + treasuryLevel * 0.5); // +50% per level
            }
            convertedGold += Math.floor(baseReward);
          }
        }
        
        // Grant gold for converted units
        if(convertedGold > 0) {
          game.gold += convertedGold;
          toast(`💀 Converted units reward: +${convertedGold}g!`, 2000);
        }
        
        // Clear all friendly units (cavalry, angelic knights, and converted enemies) when wave ends
        // Note: Undead Dragon is NOT cleared - it persists between waves
        game.enemies = game.enemies.filter(e => e.type !== 'cavalry' && e.type !== 'angelic' && e.type !== 'midas' && e.type !== 'goldenangelic' && e.type !== 'converted');
        
        // Reset cavalry cooldown between waves
        game.cavalryTimer = 0;
        
        // Pay out interest from King's Treasury
        if(game.upgrades.treasury > 0 && game.treasuryInterest > 0) {
          const interestPayout = Math.floor(game.treasuryInterest);
          game.gold += interestPayout;
          game.treasuryInterest = 0; // Reset interest
          toast(`💎 Interest paid: +${interestPayout}g!`, 2000);
        }
        
        game.state = STATE.UPGRADE; 
        game.wave++; 
        planNextWave(); 
        buildUpgradeUI(); 
        showOverlay(true); 
        persist(); 
        
        // Show intel box when entering shop phase
        const intelBox = document.getElementById('intelBox');
        if(intelBox) {
          intelBox.style.display = 'block';
          intelBox.style.top = '90px';
        }
      }
      function gameOver(){ game.state = STATE.OVER; game.high = Math.max(game.high, Math.floor(game.score)); persist(); buildGameOverUI(); showOverlay(true); }
      function togglePause(){ if(game.state===STATE.PLAY){ game.state=STATE.PAUSE; showOverlay(true); buildPauseUI(); } else if(game.state===STATE.PAUSE){ showOverlay(false); game.state=STATE.PLAY; game.last=performance.now(); requestAnimationFrame(loop); } }

      function planNextWave(){ const w = game.wave; const hpScale = Math.pow(1.10, w-1); const list=[]; const boss = (w%5===0);
        
        // Progressive enemy introduction - one new type every 3-4 waves
        const getAvailableEnemies = (wave) => {
          if(wave <= 1) return ['squire'];
          if(wave <= 3) return ['squire', 'knight'];
          if(wave <= 6) return ['squire', 'knight', 'lancer'];
          if(wave <= 9) return ['squire', 'knight', 'lancer', 'pegasus'];
          if(wave <= 12) return ['squire', 'knight', 'lancer', 'pegasus', 'cleric'];
          if(wave <= 15) return ['squire', 'knight', 'lancer', 'pegasus', 'cleric', 'jester'];
          return ['squire', 'knight', 'lancer', 'pegasus', 'cleric', 'jester', 'wizard'];
        };
        
        if(w===1){ 
          // Tutorial wave - fewer enemies, slower, but more health
          for(let i=0;i<6;i++) list.push({type:'squire', hpScale: hpScale * 1.5}); 
          setBattleMessage('⚔️ THE SQUIRES APPROACH!', 3.0, '#ff00ff');
        }
        else if(w===2){ 
          // Introduction to knights
          for(let i=0;i<6;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<4;i++) list.push({type:'knight', hpScale}); 
          setBattleMessage('🛡️ KNIGHTS JOIN THE BATTLE!', 3.0, '#00ffff');
        }
        else if(w===3){ 
          // More knights
          for(let i=0;i<4;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<6;i++) list.push({type:'knight', hpScale}); 
          setBattleMessage('🛡️ KNIGHT FORMATION!', 3.0, '#00ffff');
        }
        else if(w===4){ 
          // Introduction to lancers
          for(let i=0;i<5;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<3;i++) list.push({type:'knight', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'lancer', hpScale}); 
          setBattleMessage('🗡️ LANCERS CHARGE!', 3.0, '#ffff00');
        }
        else if(w===5){ 
          // Boss wave
          list.push({type:'dragon', hpScale}); 
          for(let i=0;i<8;i++) list.push({type:'squire', hpScale});
          setBattleMessage('🐉 DRAGON AWAKENS!', 4.0, '#ff0088');
          showAchievement('BOSS BATTLE!');
        }
        else if(w===6){ 
          // More lancers
          for(let i=0;i<4;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<3;i++) list.push({type:'knight', hpScale}); 
          for(let i=0;i<4;i++) list.push({type:'lancer', hpScale}); 
          setBattleMessage('🗡️ LANCER ASSAULT!', 3.0, '#ffff00');
        }
        else if(w===7){ 
          // Introduction to pegasus
          for(let i=0;i<4;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<3;i++) list.push({type:'knight', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'lancer', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'pegasus', hpScale}); 
          setBattleMessage('🦅 PEGASUS FLYERS!', 3.0, '#00ff88');
        }
        else if(w===10){ 
          // Introduction to clerics
          for(let i=0;i<4;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<3;i++) list.push({type:'knight', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'lancer', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'pegasus', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'cleric', hpScale}); 
          setBattleMessage('💚 CLERICS ARRIVE!', 3.0, '#88ff00');
        }
        else if(w===13){ 
          // Introduction to jesters
          for(let i=0;i<4;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<3;i++) list.push({type:'knight', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'lancer', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'pegasus', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'cleric', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'jester', hpScale}); 
          setBattleMessage('🃏 JESTERS PERFORM!', 3.0, '#ff8800');
        }
        else if(w===16){ 
          // Introduction to wizards
          for(let i=0;i<4;i++) list.push({type:'squire', hpScale}); 
          for(let i=0;i<3;i++) list.push({type:'knight', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'lancer', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'pegasus', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'cleric', hpScale}); 
          for(let i=0;i<2;i++) list.push({type:'jester', hpScale}); 
          for(let i=0;i<1;i++) list.push({type:'wizard', hpScale}); 
          setBattleMessage('⭐ WIZARDS CAST!', 3.0, '#ff88ff');
        }
        else if(boss){ 
          // Boss wave - alternate between Dragon and Golem
          const isGolemWave = (w % 10 === 0); // Every 10th wave (10, 20, 30...) gets Golem
          const bossType = isGolemWave ? 'golem' : 'dragon';
          const bossMessage = isGolemWave ? '🗿 GOLEM AWAKENS!' : '🐉 DRAGON AWAKENS!';
          const bossColor = isGolemWave ? '#8B4513' : '#ff0088';
          
          list.push({type: bossType, hpScale}); 
          for(let i=0;i<8;i++) list.push({type:'squire', hpScale});
          setBattleMessage(bossMessage, 4.0, bossColor);
          showAchievement('BOSS BATTLE!');
        }
        else { 
          // Random waves with progressive enemy types
          const options = getAvailableEnemies(w);
          const enemyCount = 8 + Math.floor(w * 1.2);
          for(let i=0;i<enemyCount;i++) 
            list.push({type: options[randInt(0,options.length-1)], hpScale}); 
        }
        game.nextWave = list;
      }
      
      function planAndStartWave(){ planNextWave(); spawnWave(game.nextWave); }
      function spawnWave(list){
        // Stagger spawns, but make the first enemy appear very quickly
        let t = 0.02; // even faster first spawn for immediate feedback
        const baseGap = game.wave === 1 ? 0.25 : 0.12; // slower for wave 1
        const jitter = game.wave === 1 ? 0.15 : 0.06;  // more jitter for wave 1
        game._spawns = [];
        for (const s of list) {
          t += baseGap + rand(0, jitter);
          game._spawns.push({ s, t });
        }
        game._spawnedAny = false;
      }

      // ============================
      // Upgrades UI and Logic
      // ============================
      function upgradeDefs(){ return [
        { key:'multishot', name:'Multi-Arrow', desc:'Fire +1 arrow per level', icon: '→' },
        { key:'piercing',  name:'Piercing Shot', desc:'Arrows pierce +1 enemy per level', icon: '→' },
        { key:'explosive', name:'Explosive Tips', desc:'Arrows explode on impact', icon: '→' },
        { key:'rapid',     name:'Rapid Fire', desc:'+25% arrow speed & fire rate per level', icon: '→' },
        { key:'crit',      name:'Critical Strike', desc:'+35% damage & +15% combo per level', icon: '→' },
        { key:'ballista',  name:'Royal Turrets', desc:'Auto-firing turrets (1 tower per level)', icon: '→' },
        { key:'oil',       name:'Electric Moat', desc:'Electric rings that burn enemies', icon: '→' },
        { key:'treasury',  name:'King\'s Treasury', desc:'+50% gold per kill & 10% Interest per level', icon: '→' },
        { key:'fort',      name:'Tower Fortifications', desc:'+25% max HP & heal per level', icon: '→' },
        { key:'sniper',    name:'Sniper Shot', desc:'3x damage piercing beam (+50% damage & width per level)', icon: '→', primordial: true },
        { key:'poison',    name:'Poison Arrow', desc:'Apply infinite stacking poison damage', icon: '→' },
        { key:'cavalry',   name:'Cavalry Charge', desc:'Automatically spawns X knights every 10s (X = level)', icon: '→' },
        { key:'boomerang', name:'Boomerang Blade', desc:'Large projectile that returns (+50% size & damage per level)', icon: '↩', primordial: true },
        { key:'necromancy', name:'Time Necromancy', desc:'Time slow kills convert enemies (+2s duration & +25% stats per level)', icon: '💀' },
        { key:'flamecannon', name:'Flame Cannon', desc:'Constant fire stream (+15% range/width, +1 base damage, +1 stack multiplier per level)', icon: '🔥', primordial: true },
        { key:'homingstrike', name:'Homing Strike', desc:'Seeking projectile that speeds up and explodes (+25% damage, speed & radius per level)', icon: '🎯', primordial: true },
        { key:'divineaegis', name:'Divine Aegis', desc:'Semi-circle shield that absorbs projectiles (+25% size & health per level)', icon: '🛡️' },
        { key:'angelicknights', name:'Angelic Knights', desc:'Cavalry knights heal castle when dealing damage (+2s duration per level)', icon: '👼', requires: ['divineaegis', 'cavalry'] },
        { key:'midasknights', name:'Midas Knights', desc:'Golden knights grant x2 gold per kill (+1x per level, bonus stats based on gold)', icon: '💰', requires: ['cavalry', 'treasury'] },
        { key:'radiantaegis', name:'Radiant Aegis', desc:'Divine Aegis releases flame projectiles (+25% burn damage & projectile size per level)', icon: '✨', requires: ['divineaegis', 'oil'] },
        { key:'dragonkinlord', name:'Dragonkin Lord', desc:'Execute dragons with time slow sniper shots to permanently recruit them as Undead Dragons', icon: '🐉', heroic: true },
        { key:'orbitalstrike', name:'Orbital Strike', desc:'Sniper shots trigger orbital strikes (+25% radius & damage per level)', icon: '☄️' },
        { key:'micasa', name:'MI CASA SU CASA?', desc:'Secret: Build a massive central tower with chaining attacks', icon: '🏗️', secret: true },
      ]; }

      function buildUpgradeUI(){ 
        const body = ui.ovBody; 
        body.innerHTML=''; 
        ui.ovTitle.textContent = '⚔️ CHOOSE YOUR POWER'; 
        ui.ovSub.textContent = `Wave ${game.wave} approaches! Select an upgrade:`; 
        console.log('Building upgrade UI, wave:', game.wave);
        
        // Ensure next wave is planned
        if (!game.nextWave || game.nextWave.length === 0) {
          planNextWave();
        }
        
        const defs = upgradeDefs(); 
        const picks = []; 
        const pool = defs.filter(d=>d.key!=='fort');
        
        // Track turns without upgrades for secret ability
        if(!game.turnsWithoutUpgrade) game.turnsWithoutUpgrade = 0;
        if(!game.lastUpgradeWave) game.lastUpgradeWave = 0;
        if(!game.micasaShown) game.micasaShown = false;
        
        if(game.wave > game.lastUpgradeWave) {
          game.turnsWithoutUpgrade++;
          game.lastUpgradeWave = game.wave;
        }
        
        // Filter out primordial upgrades that conflict with already selected ones
        const primordialKeys = defs.filter(d => d.primordial).map(d => d.key);
        const anyPrimordialTaken = primordialKeys.some(k => (game.upgrades[k]||0) > 0);
        const availablePool = pool.filter(upgrade => {
          // Check for secret upgrades
          if(upgrade.secret) {
            if(upgrade.key === 'micasa') {
              // Only show if no upgrades purchased for 3 turns AND hasn't been shown before
              return game.turnsWithoutUpgrade >= 3 && (game.upgrades.micasa || 0) === 0 && !game.micasaShown;
            }
            return false; // Other secret upgrades not implemented yet
          }
          
          if (!upgrade.primordial) {
            // Check if upgrade has requirements
            if(upgrade.requires) {
              return upgrade.requires.every(req => (game.upgrades[req]||0) > 0);
            }
            // Special check for Heroic abilities
            if(upgrade.heroic) {
              if(upgrade.key === 'dragonkinlord') {
                // Dragonkin Lord requires Time Necromancy level 5 and can only be purchased once
                const necroLevel = game.upgrades.necromancy || 0;
                const hasDragonkin = game.dragonkinLord || false;
                return necroLevel >= 5 && !hasDragonkin;
              }
              return false; // Other heroic abilities not implemented yet
            }
            return true;
          }
          return !anyPrimordialTaken;
        });
        
        // Check if MI CASA SU CASA should be guaranteed
        const shouldShowMicasa = game.turnsWithoutUpgrade >= 3 && (game.upgrades.micasa || 0) === 0 && !game.micasaShown;
        const micasaUpgrade = availablePool.find(u => u.key === 'micasa');
        
        // If MI CASA should be shown, add it first
        if(shouldShowMicasa && micasaUpgrade) {
          picks.push(micasaUpgrade);
          game.micasaShown = true; // Mark as shown so it won't appear again
          
          // Remove it from available pool
          const micasaIndex = availablePool.indexOf(micasaUpgrade);
          if(micasaIndex > -1) {
            availablePool.splice(micasaIndex, 1);
          }
        }
        
        while(picks.length<5 && availablePool.length > 0){ 
          const c = availablePool[randInt(0,availablePool.length-1)]; 
          if(!picks.includes(c)) {
            picks.push(c);
            
            // If this is a primordial upgrade, remove ALL other primordial upgrades from available pool
            if(c.primordial) {
              for(let i = availablePool.length - 1; i >= 0; i--) {
                if(availablePool[i].primordial) {
                  availablePool.splice(i, 1);
                }
              }
            }
          } 
        }
        // Render a helper to make adding cards simpler
        function addCard(u){
          const level = game.upgrades[u.key]||0; 
          const cost = Math.floor(50 + level * 25); // Base cost + level scaling
          
          const card = document.createElement('div'); 
          card.className='card'; 
          card.style.display = 'flex';
          card.style.flexDirection = 'column';
          card.style.gap = '12px';
          card.style.position = 'relative';
          
          // Add golden glow for primordial upgrades
          if(u.primordial) {
            card.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(192,192,192,0.1))';
            card.style.border = '2px solid';
            card.style.borderImage = 'linear-gradient(45deg, #ffd700, #c0c0c0) 1';
            card.style.boxShadow = '0 0 20px rgba(255,215,0,0.6)';
          }
          
          // Add black/white neon glow for Angelic Knights
          if(u.key === 'angelicknights') {
            card.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(255,255,255,0.1))';
            card.style.border = '2px solid';
            card.style.borderImage = 'linear-gradient(45deg, #000000, #ffffff) 1';
            card.style.boxShadow = '0 0 20px rgba(255,255,255,0.6)';
            card.style.animation = 'shimmer 2s ease-in-out infinite, borderShimmer 3s ease-in-out infinite';
            
            // Add sparkle elements
            for(let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.style.position = 'absolute';
              sparkle.style.width = '8px';
              sparkle.style.height = '8px';
              sparkle.style.background = '#ffffff';
              sparkle.style.borderRadius = '50%';
              sparkle.style.boxShadow = '0 0 10px #ffffff';
              sparkle.style.animation = `sparkle 2s ease-in-out infinite ${i * 0.3}s`;
              sparkle.style.pointerEvents = 'none';
              
              // Position sparkles around the card
              const angle = (i / 6) * Math.PI * 2;
              const radius = 80;
              sparkle.style.left = `calc(50% + ${Math.cos(angle) * radius}px)`;
              sparkle.style.top = `calc(50% + ${Math.sin(angle) * radius}px)`;
              
              card.appendChild(sparkle);
            }
          }
          
          // Add neon black/white glow for Radiant Aegis
          if(u.key === 'radiantaegis') {
            card.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(255,255,255,0.1))';
            card.style.border = '2px solid';
            card.style.borderImage = 'linear-gradient(45deg, #000000, #ffffff) 1';
            card.style.boxShadow = '0 0 20px rgba(255,255,255,0.6)';
            card.style.animation = 'shimmer 2s ease-in-out infinite, borderShimmer 3s ease-in-out infinite';
            
            // Add sparkle elements
            for(let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.style.position = 'absolute';
              sparkle.style.width = '8px';
              sparkle.style.height = '8px';
              sparkle.style.background = '#ffffff';
              sparkle.style.borderRadius = '50%';
              sparkle.style.boxShadow = '0 0 10px #ffffff';
              sparkle.style.animation = `sparkle 2s ease-in-out infinite ${i * 0.3}s`;
              sparkle.style.pointerEvents = 'none';
              
              // Position sparkles around the card
              const angle = (i / 6) * Math.PI * 2;
              const radius = 80;
              sparkle.style.left = `calc(50% + ${Math.cos(angle) * radius}px)`;
              sparkle.style.top = `calc(50% + ${Math.sin(angle) * radius}px)`;
              
              card.appendChild(sparkle);
            }
          }
          
          // Add black/white neon glow for Midas Knights (combo upgrade)
          if(u.key === 'midasknights') {
            card.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(255,255,255,0.1))';
            card.style.border = '2px solid';
            card.style.borderImage = 'linear-gradient(45deg, #000000, #ffffff) 1';
            card.style.boxShadow = '0 0 20px rgba(255,255,255,0.6)';
            card.style.animation = 'shimmer 2s ease-in-out infinite, borderShimmer 3s ease-in-out infinite';
            
            // Add sparkle elements
            for(let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.style.position = 'absolute';
              sparkle.style.width = '8px';
              sparkle.style.height = '8px';
              sparkle.style.background = '#ffffff';
              sparkle.style.borderRadius = '50%';
              sparkle.style.boxShadow = '0 0 10px #ffffff';
              sparkle.style.animation = `sparkle 2s ease-in-out infinite ${i * 0.3}s`;
              sparkle.style.pointerEvents = 'none';
              
              // Position sparkles around the card
              const angle = (i / 6) * Math.PI * 2;
              const radius = 80;
              sparkle.style.left = `calc(50% + ${Math.cos(angle) * radius}px)`;
              sparkle.style.top = `calc(50% + ${Math.sin(angle) * radius}px)`;
              
              card.appendChild(sparkle);
            }
          }
          
          // Add neon pink glow for secret upgrades
          if(u.secret) {
            card.style.background = 'linear-gradient(135deg, rgba(255,20,147,0.3), rgba(255,105,180,0.1))';
            card.style.border = '2px solid';
            card.style.borderImage = 'linear-gradient(45deg, #ff1493, #ff69b4) 1';
            card.style.boxShadow = '0 0 25px rgba(255,20,147,0.8)';
            card.style.animation = 'shimmer 1.5s ease-in-out infinite, borderShimmer 2s ease-in-out infinite';
            
            // Add pulsing effect
            card.style.transform = 'scale(1.02)';
            card.style.transition = 'all 0.3s ease';
            
            // Add sparkle elements for secret upgrades
            for(let i = 0; i < 8; i++) {
              const sparkle = document.createElement('div');
              sparkle.style.position = 'absolute';
              sparkle.style.width = '6px';
              sparkle.style.height = '6px';
              sparkle.style.background = '#ff1493';
              sparkle.style.borderRadius = '50%';
              sparkle.style.boxShadow = '0 0 15px #ff1493';
              sparkle.style.animation = `sparkle 1.5s ease-in-out infinite ${i * 0.2}s`;
              sparkle.style.pointerEvents = 'none';
              
              // Position sparkles around the card
              const angle = (i / 8) * Math.PI * 2;
              const radius = 70;
              sparkle.style.left = `calc(50% + ${Math.cos(angle) * radius}px)`;
              sparkle.style.top = `calc(50% + ${Math.sin(angle) * radius}px)`;
              
              card.appendChild(sparkle);
            }
          }
          
          const content = document.createElement('div'); 
          content.style.flex = '1';
          // Dynamic description for fortifications
          let desc = u.desc;
          if(u.key === 'fort') {
            const healAmount = 15 + 5*level;
            desc = `Thicker walls + heal castle for +${healAmount} HP`;
          }
          
          // Special styling for combo ability titles
          let titleStyle = '';
          if(u.key === 'angelicknights' || u.key === 'radiantaegis' || u.key === 'midasknights') {
            titleStyle = `
              background: linear-gradient(45deg, #000000, #ffffff, #000000);
              background-size: 200% 200%;
              -webkit-background-clip: text;
              -webkit-text-fill-color: transparent;
              animation: textGlow 2s ease-in-out infinite, gradientShift 3s ease-in-out infinite;
              font-weight: 900;
              text-shadow: 0 0 15px #ffffff;
              position: relative;
              z-index: 10;
            `;
          }
          
          content.innerHTML = `<div class="title" style="margin-bottom:8px; ${titleStyle}">${u.name}</div><div class="desc" style="margin-bottom:8px;">${desc}</div>`; 
          
          // Level pill in bottom left
          const levelPill = document.createElement('span');
          levelPill.className = 'pill';
          levelPill.textContent = `Level ${level}`;
          levelPill.style.position = 'absolute';
          levelPill.style.bottom = '16px';
          levelPill.style.left = '16px';
          levelPill.style.margin = '0';
          
          // Special styling for combo ability level pills
          if(u.key === 'angelicknights' || u.key === 'radiantaegis' || u.key === 'midasknights') {
            levelPill.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.8), rgba(255,255,255,0.3))';
            levelPill.style.border = '1px solid #ffffff';
            levelPill.style.color = '#ffffff';
            levelPill.style.textShadow = '0 0 10px #ffffff';
            levelPill.style.animation = 'neonPulse 1.5s ease-in-out infinite';
            levelPill.style.boxShadow = '0 0 15px rgba(255,255,255,0.8)';
          }
          
          const btn=document.createElement('button'); 
          btn.textContent=`${cost}g`; 
          btn.style.position = 'absolute';
          btn.style.bottom = '16px';
          btn.style.right = '16px';
          btn.style.margin = '0';
          const refreshBtnState = ()=>{
            const canAfford = game.gold >= cost;
            btn.disabled = !canAfford;
            if(!canAfford){
              btn.style.background = 'linear-gradient(135deg, #aa0000, #880000)';
              btn.style.borderColor = '#ff4444';
              btn.style.color = '#ffffff';
              btn.style.opacity = '0.9';
            } else {
              btn.style.background = '';
              btn.style.borderColor = '';
              btn.style.color = '';
              btn.style.opacity = '';
            }
          };
          refreshBtnState();
          btn.addEventListener('click',()=>{ 
            if(game.gold >= cost) {
              game.gold -= cost;
              game.upgrades[u.key]=(game.upgrades[u.key]||0)+1; 
              
              // Reset turn counter when any upgrade is purchased
              game.turnsWithoutUpgrade = 0;
              
              // Mark MI CASA as shown if this is the MI CASA upgrade
              if(u.key === 'micasa') {
                game.micasaShown = true;
              }
              
              sfx.powerup(); 
              updateHUD(); 
              persist(); 
              toast(`${u.name} UPGRADED!`, 1500);
              if(u.key==='fort'){ 
                console.log('Applying fortifications, level before:', game.upgrades.fort);
                applyFortifications(); 
                console.log('Fortifications applied, new castle HP:', game.castleHp, '/', game.castleMax);
              }
              
              // Initialize Divine Aegis when first purchased
              if(u.key==='divineaegis'){ 
                const level = game.upgrades.divineaegis;
                const radiantLevel = game.upgrades.radiantaegis || 0;
                game.divineAegis.active = true;
                game.divineAegis.maxHp = 100 + level * 25;
                game.divineAegis.hp = game.divineAegis.maxHp;
                // Size scales with both Divine Aegis and Radiant Aegis levels
                game.divineAegis.size = 48 + level * 12 + radiantLevel * 8; // Base 48 + 12 per level + 8 per radiant level
                game.divineAegis.respawnTimer = 0;

              }
              
              // Update Divine Aegis when Radiant Aegis is purchased
              if(u.key==='radiantaegis'){ 
                const level = game.upgrades.divineaegis;
                const radiantLevel = game.upgrades.radiantaegis;
                // Update size to include Radiant Aegis scaling
                game.divineAegis.size = 48 + level * 12 + radiantLevel * 8;
                // Visual upgrade effect
                spawnParticles(CENTER.x, CENTER.y, '#ff0000', 30, 1.5);
                setBattleMessage('✨ RADIANT AEGIS ACTIVATED!', 3.0, '#ff0000');

              }
              
              // Activate Dragonkin Lord ability
              if(u.key==='dragonkinlord'){ 
                game.dragonkinLord = true;
                // Visual upgrade effect
                spawnParticles(CENTER.x, CENTER.y, '#ffd700', 50, 2.0);
                setBattleMessage('🐉 DRAGONKIN LORD AWAKENED!', 4.0, '#ffd700');
                showAchievement('DRAGONKIN LORD!');
              }
              
              // Activate MI CASA SU CASA ability
              if(u.key==='micasa'){ 
                // Initialize the Tower of Babel
                game.centralTower = {
                  // Construction state
                  constructionProgress: 0,
                  maxProgress: 100,
                  towerBuilt: false,
                  scaffoldHeight: 0,
                  towerLevels: 0,
                  maxLevels: 7, // Tower of Babel has 7 levels
                  
                  // Engineer properties
                  engineerActive: true,
                  engineerHp: 100,
                  engineerMaxHp: 100,
                  engineerX: CENTER.x,
                  engineerY: CENTER.y,
                  engineerSpeed: 60,
                  engineerState: 'collecting', // 'collecting', 'building', 'repairing'
                  
                  // Resource collection
                  resourceTarget: null,
                  carryingResource: null,
                  stonesCollected: 0,
                  woodCollected: 0,
                  stonesNeeded: 5,
                  woodNeeded: 5,
                  
                  // Building/repair timers
                  lastBuildTime: 0,
                  buildInterval: 2.0,
                  buildAmount: 5,
                  repairTimer: 0,
                  repairInterval: 3.0,
                  repairAmount: 3,
                  
                  // Combat properties
                  lastShotTime: 0,
                  shotInterval: 1.5,
                  damage: 80,
                  chainDamage: 40,
                  range: 875, // Increased by 250% (250 * 3.5)
                  chainRange: 420 // Increased by 250% (120 * 3.5)
                };
                
                // Spawn resources around the map (outside castle boundaries)
                game.resources = [];
                for(let i = 0; i < 5; i++) {
                  // Spawn stones
                  const stoneAngle = (Math.PI * 2 / 5) * i;
                  const stoneDist = CASTLE.r + 80 + Math.random() * 150; // Outside castle
                  game.resources.push({
                    type: 'stone',
                    x: CENTER.x + Math.cos(stoneAngle) * stoneDist,
                    y: CENTER.y + Math.sin(stoneAngle) * stoneDist,
                    collected: false
                  });
                  
                  // Spawn wood
                  const woodAngle = stoneAngle + Math.PI / 5;
                  const woodDist = CASTLE.r + 80 + Math.random() * 150;
                  game.resources.push({
                    type: 'wood',
                    x: CENTER.x + Math.cos(woodAngle) * woodDist,
                    y: CENTER.y + Math.sin(woodAngle) * woodDist,
                    collected: false
                  });
                }
                
                // Initialize lightning bolts array
                if(!game.lightningBolts) game.lightningBolts = [];
                
                // Visual upgrade effect
                spawnParticles(CENTER.x, CENTER.y, '#ff1493', 60, 2.0);
                setBattleMessage('🏗️ TOWER OF BABEL ACTIVATED!', 4.0, '#ff1493');
                showAchievement('SECRET DISCOVERED!');
              }
              
              // Update HUD immediately after fortification
              updateHUD();
              
              // Rebuild the UI to show updated costs and descriptions
              buildUpgradeUI();
            } else {
              toast('Not enough gold!', 1000);
              refreshBtnState();
            }
          }); 
          
          card.appendChild(content); 
          card.appendChild(levelPill);
          card.appendChild(btn); 
          
          // Add special hover effects for combo abilities
          if(u.key === 'angelicknights' || u.key === 'radiantaegis' || u.key === 'midasknights') {
            card.addEventListener('mouseenter', () => {
              card.style.transform = 'translateY(-8px) scale(1.03)';
              card.style.boxShadow = '0 15px 50px rgba(255,255,255,0.9)';
              card.style.animation = 'shimmer 1s ease-in-out infinite, borderShimmer 1.5s ease-in-out infinite';
            });
            
            card.addEventListener('mouseleave', () => {
              card.style.transform = 'translateY(0px) scale(1)';
              card.style.boxShadow = '0 0 20px rgba(255,255,255,0.6)';
              card.style.animation = 'shimmer 2s ease-in-out infinite, borderShimmer 3s ease-in-out infinite';
            });
          }
          
          // Add Heroic ability styling
          if(u.heroic) {
            card.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.4), rgba(255,255,255,0.15), rgba(255,215,0,0.1))';
            card.style.border = '3px solid';
            card.style.borderImage = 'linear-gradient(45deg, #000000, #ffffff, #ffd700, #000000) 1';
            card.style.boxShadow = '0 0 30px rgba(255,255,255,0.8), 0 0 60px rgba(255,215,0,0.6)';
            card.style.animation = 'heroicShimmer 3s ease-in-out infinite, heroicBorder 4s ease-in-out infinite';
            
            // Add enhanced sparkle elements for heroic abilities
            for(let i = 0; i < 12; i++) {
              const sparkle = document.createElement('div');
              sparkle.style.position = 'absolute';
              sparkle.style.width = '12px';
              sparkle.style.height = '12px';
              sparkle.style.background = i % 3 === 0 ? '#ffffff' : i % 3 === 1 ? '#ffd700' : '#000000';
              sparkle.style.borderRadius = '50%';
              sparkle.style.boxShadow = `0 0 15px ${i % 3 === 0 ? '#ffffff' : i % 3 === 1 ? '#ffd700' : '#000000'}`;
              sparkle.style.animation = `heroicSparkle 3s ease-in-out infinite ${i * 0.25}s`;
              sparkle.style.pointerEvents = 'none';
              
              // Position sparkles in a more complex pattern
              const angle = (i / 12) * Math.PI * 2;
              const radius = 60 + (i % 3) * 20;
              sparkle.style.left = `calc(50% + ${Math.cos(angle) * radius}px)`;
              sparkle.style.top = `calc(50% + ${Math.sin(angle) * radius}px)`;
              
              card.appendChild(sparkle);
            }
            
            // Enhanced hover effects for heroic abilities
            card.addEventListener('mouseenter', () => {
              card.style.transform = 'translateY(-12px) scale(1.05)';
              card.style.boxShadow = '0 20px 80px rgba(255,255,255,1.0), 0 0 120px rgba(255,215,0,0.8)';
              card.style.animation = 'heroicShimmer 1.5s ease-in-out infinite, heroicBorder 2s ease-in-out infinite';
            });
            
            card.addEventListener('mouseleave', () => {
              card.style.transform = 'translateY(0px) scale(1)';
              card.style.boxShadow = '0 0 30px rgba(255,255,255,0.8), 0 0 60px rgba(255,215,0,0.6)';
              card.style.animation = 'heroicShimmer 3s ease-in-out infinite, heroicBorder 4s ease-in-out infinite';
            });
          }
          
          body.appendChild(card);
        }
        picks.forEach(addCard);
        // Always include Fortifications as a guaranteed option
        addCard(defs.find(d=>d.key==='fort')); 

        // Show intel box outside the game window
        const intelBox = document.getElementById('intelBox');
        console.log('Intel box found:', intelBox);
        if (!intelBox) {
          console.error('Intel box not found!');
          return;
        }
        const intelContent = intelBox.querySelector('.intel-content');
        console.log('Intel content found:', intelContent);
        if (!intelContent) {
          console.error('Intel content not found!');
          return;
        }
        intelContent.innerHTML = '';
        
        // Enhanced Enemy Intel card with visual representations
        const preview = document.createElement('div');
        preview.className = 'card';
        preview.style.gridColumn = '1 / -1';
        preview.style.background = 'linear-gradient(135deg, rgba(255,0,255,0.15), rgba(0,255,255,0.1))';
        preview.style.border = '2px solid';
        preview.style.borderImage = 'linear-gradient(45deg, #ff00ff, #00ffff) 1';
        
        // Add title
        const title = document.createElement('div');
        title.className = 'title';
        title.style.color = '#ff00ff';
        title.style.textShadow = '0 0 10px #ff00ff';
        title.textContent = '🔍 ENEMY INTEL';
        preview.appendChild(title);
        
        const counts = (()=>{ 
          const c={}; 
          console.log('game.nextWave:', game.nextWave);
          if(game.nextWave && game.nextWave.length > 0) {
            game.nextWave.forEach(s=> c[s.type]=(c[s.type]||0)+1 ); 
          }
          console.log('counts object:', c);
          return c; 
        })();
        
        const createEnemyVisual = (type) => {
          const e = ENEMY[type];
          const size = 40;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          canvas.style.border = '2px solid ' + e.color;
          canvas.style.borderRadius = '8px';
          canvas.style.margin = '0 8px';
          canvas.style.background = 'rgba(0,0,0,0.3)';
          
          const ctx = canvas.getContext('2d');
          ctx.translate(size/2, size/2);
          
          // Draw enemy sprite based on type
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 8;
          
          if(type === 'squire') {
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // Sword
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(0, 12);
            ctx.stroke();
          } else if(type === 'knight') {
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // Shield
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-8, -8);
            ctx.lineTo(8, -8);
            ctx.closePath();
            ctx.fill();
          } else if(type === 'lancer') {
            ctx.fillStyle = e.color;
            ctx.fillRect(-10, -10, 20, 20);
            // Lance
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -15);
            ctx.stroke();
          } else if(type === 'pegasus') {
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(8, 8);
            ctx.lineTo(-8, 8);
            ctx.closePath();
            ctx.fill();
            // Wings
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.lineTo(-12, -6);
            ctx.moveTo(8, 0);
            ctx.lineTo(12, -6);
            ctx.stroke();
          } else if(type === 'cleric') {
            ctx.fillStyle = e.color;
            ctx.fillRect(-10, -10, 20, 20);
            // Cross
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-2, -8, 4, 16);
            ctx.fillRect(-8, -2, 16, 4);
          } else if(type === 'wizard') {
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // Star
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            for(let i=0; i<5; i++) {
              const a = (Math.PI*2/5)*i - Math.PI/2;
              const x = Math.cos(a)*8;
              const y = Math.sin(a)*8;
              if(i===0) ctx.moveTo(x,y);
              else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
          } else if(type === 'jester') {
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // Hat points
            ctx.fillStyle = '#ffffff';
            for(let i=0; i<3; i++) {
              const a = (Math.PI*2/3)*i;
              ctx.beginPath();
              ctx.arc(Math.cos(a)*8, Math.sin(a)*8, 2, 0, Math.PI*2);
              ctx.fill();
            }
          } else if(type === 'dragon') {
            ctx.fillStyle = e.color;
            ctx.fillRect(-12, -8, 24, 16);
            // Wings
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.lineTo(-18, -10);
            ctx.lineTo(-12, -8);
            ctx.moveTo(12, 0);
            ctx.lineTo(18, -10);
            ctx.lineTo(12, -8);
            ctx.fill();
          }
          
          ctx.shadowBlur = 0;
          return canvas;
        };
        
        const describe = (t)=>{
          const e=ENEMY[t];
          const lines=[];
          if(t==='squire') lines.push('⚔️ Basic melee fighter');
          if(t==='knight') lines.push('🛡️ Shielded');
          if(t==='lancer') lines.push('🗡️ Throws spears');
          if(t==='pegasus') lines.push('🦅 Flies over moat');
          if(t==='cleric') lines.push('💚 Heals nearby allies');
          if(t==='wizard') lines.push('⭐ Raises fallen once');
          if(t==='jester') lines.push('🃏 Splits into Pages');
          if(t==='dragon') lines.push('🐉 Boss - High health');
          if(t==='golem') lines.push('🗿 Boss — absorbs units, ground slam');
          return lines.join(' · ');
        };
        
        // Create enemy intel entries for external box
        const enemyTypes = Object.keys(counts);
        console.log('Enemy intel - counts:', counts, 'types:', enemyTypes);
        
        if(enemyTypes.length > 0) {
          enemyTypes.forEach(k => {
            const visual = createEnemyVisual(k);
            const entry = document.createElement('div');
            entry.className = 'intel-enemy';
            
            // Set canvas border color to match enemy color
            visual.style.borderColor = ENEMY[k].color;
            
            const info = document.createElement('div');
            info.className = 'intel-enemy-info';
            
            const name = document.createElement('div');
            name.className = 'intel-enemy-name';
            name.style.color = ENEMY[k].color;
            name.style.textShadow = `0 0 5px ${ENEMY[k].color}`;
            name.textContent = ENEMY[k].name;
            
            const desc = document.createElement('div');
            desc.className = 'intel-enemy-desc';
            desc.textContent = describe(k);
            
            const count = document.createElement('div');
            count.className = 'intel-enemy-count';
            count.textContent = `${counts[k]}x`;
            
            info.appendChild(name);
            info.appendChild(desc);
            entry.appendChild(visual);
            entry.appendChild(info);
            entry.appendChild(count);
            
            intelContent.appendChild(entry);
          });
          
          // Show the intel box
          intelBox.classList.add('show');
          console.log('Intel box should be visible now');
          
          // Force show for debugging
          intelBox.style.display = 'block';
          intelBox.style.top = '90px';
        } else {
          // Fallback - show some basic enemy info
          const fallbackVisual = createEnemyVisual('squire');
          fallbackVisual.style.borderColor = ENEMY.squire.color;
          
          const fallbackEntry = document.createElement('div');
          fallbackEntry.className = 'intel-enemy';
          
          const fallbackInfo = document.createElement('div');
          fallbackInfo.className = 'intel-enemy-info';
          
          const fallbackName = document.createElement('div');
          fallbackName.className = 'intel-enemy-name';
          fallbackName.style.color = ENEMY.squire.color;
          fallbackName.style.textShadow = `0 0 5px ${ENEMY.squire.color}`;
          fallbackName.textContent = 'Enemy Forces';
          
          const fallbackDesc = document.createElement('div');
          fallbackDesc.className = 'intel-enemy-desc';
          fallbackDesc.textContent = '⚔️ Prepare for battle!';
          
          fallbackInfo.appendChild(fallbackName);
          fallbackInfo.appendChild(fallbackDesc);
          fallbackEntry.appendChild(fallbackVisual);
          fallbackEntry.appendChild(fallbackInfo);
          
          intelContent.appendChild(fallbackEntry);
          intelBox.classList.add('show');
          
          // Force show for debugging
          intelBox.style.display = 'block';
          intelBox.style.top = '90px';
        }
        

      }
      
      function buildGameOverUI(){ 
        ui.ovBody.innerHTML = `
          <div class="card" style="grid-column:1/-1">
            <div class="epic-title">GAME OVER</div>
            <div class="desc" style="text-align:center; font-size:18px;">
              The castle has fallen!<br><br>
              👑 Final Score: ${Math.floor(game.score)}<br>
              ⚔️ Waves Survived: ${game.wave-1}<br>
              🏆 High Score: ${Math.floor(game.high)}
            </div>
          </div>`; 
        ui.ovTitle.textContent='💀 DEFEAT'; 
        ui.ovSub.textContent='The kingdom mourns your loss...'; 
        ui.next.textContent=''; 
      }
      
      function buildPauseUI(){
        ui.ovTitle.textContent = '⏸️ PAUSED';
        ui.ovSub.textContent = 'The battle awaits your return...';
        ui.ovBody.innerHTML = `
          <div class="card" style="grid-column:1/-1">
            <div class="title">⚔️ CONTROLS</div>
            <div class="desc">
              Mouse - Move around castle & aim<br>
              Left Click - Shoot<br>
              Right Click - Charge shot<br>
              Shift - Slow motion (sniper shots + 150% speed)<br>
              WASD - Reserved for future special abilities<br>
              ESC - Pause
            </div>
          </div>`;
      }
      
      function showOverlay(show){ 
        ui.overlay.style.display = show? 'grid':'none'; 
        
        // Keep HUD visible during shop phase
        const hud = document.querySelector('.hud');
        if(hud) {
          hud.style.opacity = '1'; // Always fully visible
          hud.style.pointerEvents = show ? 'none' : 'auto';
        }
      }

      // ============================
      // Shooting & Player Mechanics
      // ============================
      let shootTimer = 0, charge = 0, charging = false;
      function getNearestEnemy(pt){ 
        let best=null,bd=Infinity; 
        for(const e of game.enemies){ 
          if(e.dead) continue; 
          if(e.invisible) continue; // Invisible enemies are always invisible now
          if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue; // Don't target friendly units
          const d=(e.x-pt.x)*(e.x-pt.x)+(e.y-pt.y)*(e.y-pt.y); 
          if(d<bd){bd=d; best=e;} 
        } 
        console.log('getNearestEnemy called from:', pt.x, pt.y, 'found:', best ? best.type : 'none');
        return best; 
      }
      
      function fire(origin, power=0){ 
        // Aim strictly at the mouse position (no auto-targeting)
        const dir = Math.atan2(mouse.y-origin.y, mouse.x-origin.x); 
        const count = 1 + (game.upgrades.multishot||0); 
        // Much narrower spread for sniper shots
        const isSniper = game.upgrades.sniper > 0 || game.dtScale < 1;
        const spread = isSniper ? 
          Math.min(Math.PI/60, 0.005 + 0.002*(count-1)) : // Very narrow for sniper
          Math.min(Math.PI/12, 0.03 + 0.02*(count-1)); // Normal spread 
        for(let i=0;i<count;i++){ 
          const off = (i-(count-1)/2) * spread; 
          const p = makeProjectile(origin.x, origin.y, dir+off, {}); 
          
          // Skip if makeProjectile returned null (sniper line effect)
          if(!p) continue;
          
          p.src = 'player';
          if(power>0.2){ 
            p.baseDmg *= 1 + power*2.0; 
            p.explosive = p.explosive || power>0.6; 
            p.size = 3 + Math.floor(power*4);
            p.color = power>0.6 ? '#ff00ff' : '#00ffff';
            p.powershot = true; // Mark as powershot for shield breaking
          } 
          // Remove wall-based damage bonus since we're using mouse movement
          game.projectiles.push(p); 
          
          // Special particle effect for time slow shots
          if(p.timeSlow) {
            spawnParticles(origin.x, origin.y, '#ffff00', 8, 0.6);
          }
        }
        sfx.shoot(); 
      }
      
      function updatePlayerPos(){ 
        // Calculate angle from castle center to mouse position for 360-degree rotation
        const mouseAngle = Math.atan2(mouse.y - CENTER.y, mouse.x - CENTER.x);
        const pos = V2.fromAngle(mouseAngle, CASTLE.r-8); 
        game.player.x = CENTER.x + pos.x; 
        game.player.y = CENTER.y + pos.y; 
        // Store the current angle for reference
        game.player.angle = mouseAngle;
      }
      
      function handleControls(dt){ 
        // Update player position based on mouse for 360-degree rotation
        updatePlayerPos();
        
        // Automatic cavalry spawn on cooldown
        if(game.upgrades.cavalry > 0 && game.cavalryTimer <= 0) {
          // Spawn multiple cavalry based on upgrade level
          const cavalryCount = game.upgrades.cavalry;
          for(let i = 0; i < cavalryCount; i++) {
            // Spawn cavalry at slightly different positions around the player
            const angle = (i / cavalryCount) * Math.PI * 2;
            const offsetX = Math.cos(angle) * 20;
            const offsetY = Math.sin(angle) * 20;
            spawnCavalry(game.player.x + offsetX, game.player.y + offsetY);
          }
          game.cavalryTimer = 10.0; // 10 second cooldown
          
          // Visual effect for cavalry spawn
          spawnParticles(game.player.x, game.player.y, '#00ff88', 30, 1.0);
          game.shake = Math.max(game.shake, 4);
        }
        
        // WASD reserved for future special abilities
        // (Currently disabled - will be used for special abilities later)
        
        // Slow motion
        if(KEYS.has('shift')){ 
          if(game.stamina>0){ 
            if(game.dtScale === 1) {
              sfx.timeSlow(); // Play sound when time slow activates
            }
            game.dtScale=0.4; 
            game.stamina=Math.max(0, game.stamina - dt*0.35); 
          } else game.dtScale=1; 
        } else { 
          game.dtScale=1; 
          game.stamina=Math.min(1, game.stamina + dt*0.25); 
        }
      }
      
      // teleportFx function removed - no longer needed with mouse-based movement
      
      function handleShooting(dt){ 
        shootTimer-=dt; // Remove wall-based speed bonus since we're using mouse movement
        
        // Cavalry timer
        if(game.cavalryTimer > 0) {
          game.cavalryTimer -= dt;
        }
        
        // Sniper reload timer
        if(game.sniperReloadTimer > 0) {
          game.sniperReloadTimer -= dt;
        }
        
        if(mouse.rdown){ 
          charging=true; 
          charge=Math.min(1, charge + dt*0.8); 
        }
        else if(charging){ 
          fire({x:game.player.x,y:game.player.y}, charge); 
          charging=false; 
          charge=0; 
        }
        if(mouse.down && shootTimer<=0){ 
          // Check sniper reload timer
          if(game.upgrades.sniper > 0 && game.sniperReloadTimer > 0) {
            return; // Can't fire while reloading
          }
          
          // Check time slow sniper reload timer
          if(game.dtScale < 1 && game.sniperReloadTimer > 0) {
            return; // Can't fire time slow sniper while reloading
          }
          
          shootTimer = Math.max(0.08, game.player.rate - 0.04*(game.upgrades.rapid||0)); 
          
          fire({x:game.player.x,y:game.player.y}, 0); // Normal shot
          
          // Set sniper reload timer (for both sniper upgrade and time slow)
          if(game.upgrades.sniper > 0 || game.dtScale < 1) {
            game.sniperReloadTimer = 1.0; // 1 second reload
          }
        }
      }

      // Auto-firing castle turrets (Ballista upgrade)
      function ballistaThink(dt){
        const lvl = game.upgrades.ballista||0; if(lvl<=0) return;
        // Support up to 8 turrets: E, W, N, S, NE, SE, SW, NW
        const maxTurrets = (lvl > 4) ? 8 : 4;
        if(!ballistaThink._t || ballistaThink._t.length < maxTurrets) ballistaThink._t = new Array(maxTurrets).fill(0).map((v,i)=> (ballistaThink._t && ballistaThink._t[i])||0);
        if(!ballistaThink._flash || ballistaThink._flash.length < maxTurrets) ballistaThink._flash = new Array(maxTurrets).fill(0).map((v,i)=> (ballistaThink._flash && ballistaThink._flash[i])||0);
        const angles = [ 
          -Math.PI/2,  // 0 N
           Math.PI/2,  // 1 S
           0,          // 2 E
           Math.PI,    // 3 W
          -Math.PI/4,  // 4 NE
           Math.PI/4,  // 5 SE
           3*Math.PI/4,// 6 SW
          -3*Math.PI/4 // 7 NW
        ];
        // Fire order prioritizes cardinals first, then diagonals
        const order = [2,3,0,1,4,5,6,7]; // E,W,N,S,NE,SE,SW,NW
        const baseRate = 2.6; // slower baseline
        const rate = Math.max(1.6, baseRate - 0.3*(lvl-1));
        const activeCount = Math.min(lvl, maxTurrets);
        for(let k=0;k<activeCount;k++){
          const i = order[k];
          ballistaThink._t[i]-=dt; ballistaThink._flash[i]=Math.max(0, ballistaThink._flash[i]-dt);
          if(ballistaThink._t[i]>0) continue;
          const pos = V2.fromAngle(angles[i], CASTLE.r-10);
          const turretPos = { x: CENTER.x+pos.x, y: CENTER.y+pos.y };
          const t = getNearestEnemy(turretPos);
          ballistaThink._t[i]= (t? rate : 0.25);
          if(!t) continue;
          const dir = Math.atan2(t.y-turretPos.y, t.x-turretPos.x);
          
          // Fire from cannon tip (25 pixels in the direction the turret is facing)
          const cannonTipX = turretPos.x + Math.cos(dir) * 25;
          const cannonTipY = turretPos.y + Math.sin(dir) * 25;
          const p = makeProjectile(cannonTipX, cannonTipY, dir, {});
          if(p) { // Check if projectile was created (not null for sniper shots)
            p.baseDmg = 12 + 6*lvl; p.crit=false; p.explosive=false; p.pierce=0; p.color = '#a0ffff'; p.src='turret';
            game.projectiles.push(p);
          }
          spawnParticles(cannonTipX, cannonTipY, '#00ffff', 4, 0.4);
          ballistaThink._flash[i]=0.12;
        }
      }

      // ============================
      // Wave Spawning & Enemy Behavior
      // ============================
      function spawnGolemWithMinions(game, x, y, hpScale) {
        // Create the golem on the edge of the map
        const spawnAngle = Math.random() * Math.PI * 2;
        const spawnDistance = 600; // Spawn much further from castle
        const golemX = x || (CENTER.x + Math.cos(spawnAngle) * spawnDistance);
        const golemY = y || (CENTER.y + Math.sin(spawnAngle) * spawnDistance);
        
        const golem = {
          type: 'golem',
          x: golemX,
          y: golemY,
          vx: 0,
          vy: 0,
          speed: 8,
          radius: 40,
          hp: 12000 * hpScale * DIFFICULTY.ENEMY_HP_MULT,
          maxHp: 12000 * hpScale * DIFFICULTY.ENEMY_HP_MULT,
          damage: 35,
          reward: 100,
          heading: 0,
          dead: false,
          color: '#8B4513',
          glowColor: '#8B4513',
          wobble: 0,
          
          // Enhanced golem properties
          suckCooldown: 2.0, // Start ready to suck immediately
          slamCooldown: 5.0,
          attachedUnits: [],
          limbUnits: {
            leftArm: [],
            rightArm: [],
            leftLeg: [],
            rightLeg: []
          },
          walkCycle: 0,
          bodyPulse: 0,
          isSlamming: false,
          initialSuckComplete: false
        };
        
        game.enemies.push(golem);
        
        // Spawn sacrificial minions around the golem for immediate absorption
        const minionTypes = ['squire', 'knight', 'lancer', 'pegasus', 'page'];
        const minionCount = 8; // Spawn 8 units to be absorbed
        
        for(let i = 0; i < minionCount; i++) {
          const angle = (Math.PI * 2 / minionCount) * i;
          const distance = 60 + Math.random() * 40;
          const minionX = golem.x + Math.cos(angle) * distance;
          const minionY = golem.y + Math.sin(angle) * distance;
          
          const minionType = minionTypes[Math.floor(Math.random() * minionTypes.length)];
          const minion = makeEnemy(minionType, hpScale);
          minion.x = minionX;
          minion.y = minionY;
          minion.isGolemSacrifice = true; // Mark for immediate absorption
          
          game.enemies.push(minion);
        }
        
        // Visual effect
        spawnParticles(golem.x, golem.y, '#8B4513', 50, 2.0);
        setBattleMessage('🗿 THE GOLEM AWAKENS!', 3.0, '#8B4513');
        game.shake = 20;
        
        return golem;
      }

      function trySpawn(dt){ 
        if(!game._spawns) return; 
        for(let i=game._spawns.length-1;i>=0;i--){ 
          const s=game._spawns[i]; 
          s.t-=dt; 
          if(s.t<=0){ 
            if(s.s.type === 'golem') {
              // Use enhanced golem spawning with sacrificial minions
              spawnGolemWithMinions(game, undefined, undefined, s.s.hpScale);
            } else {
              const enemy = makeEnemy(s.s.type, s.s.hpScale);
              game.enemies.push(enemy); 
              // Spawn effect
              spawnParticles(enemy.x, enemy.y, enemy.glowColor, 12, 0.8);
            }
            game._spawns.splice(i,1);
            game._spawnedAny = true;
          } 
        } 
      }
      
      function allDefeated(){ 
        // Require at least one enemy to have spawned to avoid instant wave completion
        // Only count actual enemies, not friendly units (cavalry, angelic knights, converted)
        const actualEnemies = game.enemies.filter(e => e.type !== 'cavalry' && e.type !== 'angelic' && e.type !== 'midas' && e.type !== 'goldenangelic' && e.type !== 'converted');
        return game._spawnedAny && (!game._spawns || game._spawns.length===0) && actualEnemies.every(e=>e.dead); 
      }

      function enemyUpdate(e, dt){ 
        // Converted enemy behavior (friendly enemies that attack other enemies)
        if(e.type === 'converted') {
          // Health decay - 10% per second
          e.hp -= e.maxHp * 0.1 * dt;
          if(e.hp <= 0) {
            e.dead = true;
            spawnParticles(e.x, e.y, '#00ff88', 15, 0.8);
            return;
          }
          
          // Find nearest enemy to attack
          let nearestEnemy = null;
          let nearestDist = Infinity;
          for(const enemy of game.enemies) {
            if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'converted') continue;
            const dx = enemy.x - e.x;
            const dy = enemy.y - e.y;
            const dist = dx*dx + dy*dy;
            if(dist < nearestDist) {
              nearestDist = dist;
              nearestEnemy = enemy;
            }
          }
          
          if(nearestEnemy) {
            // Move towards nearest enemy
            const dx = nearestEnemy.x - e.x;
            const dy = nearestEnemy.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * dt;
              e.y += (dy/dist) * e.speed * dt;
            }
            
            // Attack if close enough
            if(dist < 30) {
              nearestEnemy.hp -= e.damage * dt * 2;
              spawnParticles(nearestEnemy.x, nearestEnemy.y, '#00ff88', 3, 0.3);
            }
          }
          
          // Animation wobble
          e.wobble += dt * 3;
          return;
        }
        
        // Cavalry behavior (friendly knight that attacks enemies)
        if(e.type === 'cavalry') {
          e.life -= dt;
          if(e.life <= 0) {
            e.dead = true;
            spawnParticles(e.x, e.y, '#00ff88', 15, 0.8);
            return;
          }
          
          // Handle stun effect
          if(e.stunned) {
            e.stunTimer -= dt;
            if(e.stunTimer <= 0) {
              e.stunned = false;
            } else {
              // Skip movement and attack while stunned
              e.wobble += dt * 3;
              return;
            }
          }
          
          // Find target enemy to attack (improved targeting to avoid same targets)
          let targetEnemy = null;
          let targetDist = Infinity;
          
          // Get all available enemies
          const availableEnemies = [];
          for(const enemy of game.enemies) {
            if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
            
            // Check if this enemy is already being targeted by another friendly unit
            let isTargeted = false;
            for(const other of game.enemies) {
              if(other.type === 'cavalry' || other.type === 'angelic' || other.type === 'midas' || other.type === 'goldenangelic') {
                if(other.targetEnemy === enemy && other !== e) {
                  isTargeted = true;
                  break;
                }
              }
            }
            
            if(!isTargeted) {
              availableEnemies.push(enemy);
            }
          }
          
          // If no untargeted enemies, target any enemy
          if(availableEnemies.length === 0) {
            for(const enemy of game.enemies) {
              if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
              availableEnemies.push(enemy);
            }
          }
          
          // Find closest available enemy
          for(const enemy of availableEnemies) {
            const dx = enemy.x - e.x;
            const dy = enemy.y - e.y;
            const dist = dx*dx + dy*dy;
            
            if(dist < targetDist) {
              targetDist = dist;
              targetEnemy = enemy;
            }
          }
          
          // Store target for other units to check
          e.targetEnemy = targetEnemy;
          
          if(targetEnemy) {
            // Move towards target enemy
            const dx = targetEnemy.x - e.x;
            const dy = targetEnemy.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * dt;
              e.y += (dy/dist) * e.speed * dt;
            }
            
            // Attack if close enough
            if(dist < 30) {
              targetEnemy.hp -= e.damage * dt * 2; // High damage rate
              // Track who killed the enemy for Midas bonus
              if(targetEnemy.hp <= 0) {
                targetEnemy.killedBy = e;
              }
              spawnParticles(targetEnemy.x, targetEnemy.y, '#00ff88', 3, 0.3);
            }
          } else {
            // No enemies, move towards castle center
            const dx = CENTER.x - e.x;
            const dy = CENTER.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * 0.5 * dt;
              e.y += (dy/dist) * e.speed * 0.5 * dt;
            }
          }
          
          // Animation wobble
          e.wobble += dt * 3;
          return;
        }
        
        // Midas Knight behavior (golden knight that grants bonus gold on kills)
        if(e.type === 'midas') {
          e.life -= dt;
          if(e.life <= 0) {
            e.dead = true;
            spawnParticles(e.x, e.y, '#ffd700', 15, 0.8);
            return;
          }
          
          // Handle stun effect
          if(e.stunned) {
            e.stunTimer -= dt;
            if(e.stunTimer <= 0) {
              e.stunned = false;
            } else {
              // Skip movement and attack while stunned
              e.wobble += dt * 3;
              return;
            }
          }
          
          // Find target enemy to attack (improved targeting to avoid same targets)
          let targetEnemy = null;
          let targetDist = Infinity;
          
          // Get all available enemies
          const availableEnemies = [];
          for(const enemy of game.enemies) {
            if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
            
            // Check if this enemy is already being targeted by another friendly unit
            let isTargeted = false;
            for(const other of game.enemies) {
              if(other.type === 'cavalry' || other.type === 'angelic' || other.type === 'midas' || other.type === 'goldenangelic') {
                if(other.targetEnemy === enemy && other !== e) {
                  isTargeted = true;
                  break;
                }
              }
            }
            
            if(!isTargeted) {
              availableEnemies.push(enemy);
            }
          }
          
          // If no untargeted enemies, target any enemy
          if(availableEnemies.length === 0) {
            for(const enemy of game.enemies) {
              if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
              availableEnemies.push(enemy);
            }
          }
          
          // Find closest available enemy
          for(const enemy of availableEnemies) {
            const dx = enemy.x - e.x;
            const dy = enemy.y - e.y;
            const dist = dx*dx + dy*dy;
            
            if(dist < targetDist) {
              targetDist = dist;
              targetEnemy = enemy;
            }
          }
          
          // Store target for other units to check
          e.targetEnemy = targetEnemy;
          
          if(targetEnemy) {
            // Move towards target enemy
            const dx = targetEnemy.x - e.x;
            const dy = targetEnemy.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * dt;
              e.y += (dy/dist) * e.speed * dt;
            }
            
            // Attack if close enough
            if(dist < 30) {
              targetEnemy.hp -= e.damage * dt * 2; // High damage rate
              // Track who killed the enemy for Midas bonus
              if(targetEnemy.hp <= 0) {
                targetEnemy.killedBy = e;
              }
              spawnParticles(targetEnemy.x, targetEnemy.y, '#ffd700', 3, 0.3);
            }
          } else {
            // No enemies, move towards castle center
            const dx = CENTER.x - e.x;
            const dy = CENTER.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * 0.5 * dt;
              e.y += (dy/dist) * e.speed * 0.5 * dt;
            }
          }
          
          // Animation wobble with golden glow
          e.wobble += dt * 3;
          return;
        }
        
        // Angelic Knight behavior (healing cavalry that heals castle when dealing damage)
        if(e.type === 'angelic') {
          e.life -= dt;
          if(e.life <= 0) {
            e.dead = true;
            spawnParticles(e.x, e.y, '#ff4444', 15, 0.8);
            return;
          }
          
          // Handle stun effect
          if(e.stunned) {
            e.stunTimer -= dt;
            if(e.stunTimer <= 0) {
              e.stunned = false;
            } else {
              // Skip movement and attack while stunned
              e.wobble += dt * 3;
              return;
            }
          }
          
          // Initialize healing cooldown if not exists
          if(e.healCooldown === undefined) e.healCooldown = 0;
          e.healCooldown -= dt;
          
          // Find target enemy to attack (improved targeting to avoid same targets)
          let targetEnemy = null;
          let targetDist = Infinity;
          
          // Get all available enemies
          const availableEnemies = [];
          for(const enemy of game.enemies) {
            if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
            
            // Check if this enemy is already being targeted by another friendly unit
            let isTargeted = false;
            for(const other of game.enemies) {
              if(other.type === 'cavalry' || other.type === 'angelic' || other.type === 'midas' || other.type === 'goldenangelic') {
                if(other.targetEnemy === enemy && other !== e) {
                  isTargeted = true;
                  break;
                }
              }
            }
            
            if(!isTargeted) {
              availableEnemies.push(enemy);
            }
          }
          
          // If no untargeted enemies, target any enemy
          if(availableEnemies.length === 0) {
            for(const enemy of game.enemies) {
              if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
              availableEnemies.push(enemy);
            }
          }
          
          // Find closest available enemy
          for(const enemy of availableEnemies) {
            const dx = enemy.x - e.x;
            const dy = enemy.y - e.y;
            const dist = dx*dx + dy*dy;
            
            if(dist < targetDist) {
              targetDist = dist;
              targetEnemy = enemy;
            }
          }
          
          // Store target for other units to check
          e.targetEnemy = targetEnemy;
          
          if(targetEnemy) {
            // Move towards target enemy
            const dx = targetEnemy.x - e.x;
            const dy = targetEnemy.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * dt;
              e.y += (dy/dist) * e.speed * dt;
            }
            
            // Attack if close enough and heal castle
            if(dist < 30) {
              const damageDealt = e.damage * dt * 2;
              targetEnemy.hp -= damageDealt;
              // Track who killed the enemy for Midas bonus
              if(targetEnemy.hp <= 0) {
                targetEnemy.killedBy = e;
              }
              
              // Heal castle for the damage dealt (with cooldown)
              if(e.healCooldown <= 0) {
                const healAmount = 5; // Fixed healing amount per hit
                game.castleHp = Math.min(game.castleHp + healAmount, game.castleMax);
                spawnText(e.x, e.y-20, `+${healAmount}`, '#00ff00', 1.0, 16);
                spawnParticles(e.x, e.y, '#00ff00', 8, 0.6); // Add healing particles
                e.healCooldown = 0.5; // 0.5 second cooldown between heals
              }
              
              spawnParticles(targetEnemy.x, targetEnemy.y, '#ff4444', 3, 0.3);
            }
          } else {
            // No enemies, move towards castle center
            const dx = CENTER.x - e.x;
            const dy = CENTER.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * 0.5 * dt;
              e.y += (dy/dist) * e.speed * 0.5 * dt;
            }
          }
          
          // Animation wobble with pulsing white glow
          e.wobble += dt * 3;
          return;
        }
        
        // Golden Angelic Knight behavior (combines both angelic healing and midas gold bonuses)
        if(e.type === 'goldenangelic') {
          e.life -= dt;
          if(e.life <= 0) {
            e.dead = true;
            spawnParticles(e.x, e.y, '#ffd700', 15, 0.8);
            return;
          }
          
          // Handle stun effect
          if(e.stunned) {
            e.stunTimer -= dt;
            if(e.stunTimer <= 0) {
              e.stunned = false;
            } else {
              // Skip movement and attack while stunned
              e.wobble += dt * 3;
              return;
            }
          }
          
          // Initialize healing cooldown if not exists
          if(e.healCooldown === undefined) e.healCooldown = 0;
          e.healCooldown -= dt;
          
          // Find target enemy to attack (improved targeting to avoid same targets)
          let targetEnemy = null;
          let targetDist = Infinity;
          
          // Get all available enemies
          const availableEnemies = [];
          for(const enemy of game.enemies) {
            if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
            
            // Check if this enemy is already being targeted by another friendly unit
            let isTargeted = false;
            for(const other of game.enemies) {
              if(other.type === 'cavalry' || other.type === 'angelic' || other.type === 'midas' || other.type === 'goldenangelic') {
                if(other.targetEnemy === enemy && other !== e) {
                  isTargeted = true;
                  break;
                }
              }
            }
            
            if(!isTargeted) {
              availableEnemies.push(enemy);
            }
          }
          
          // If no untargeted enemies, target any enemy
          if(availableEnemies.length === 0) {
            for(const enemy of game.enemies) {
              if(enemy.dead || enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
              availableEnemies.push(enemy);
            }
          }
          
          // Find closest available enemy
          for(const enemy of availableEnemies) {
            const dx = enemy.x - e.x;
            const dy = enemy.y - e.y;
            const dist = dx*dx + dy*dy;
            
            if(dist < targetDist) {
              targetDist = dist;
              targetEnemy = enemy;
            }
          }
          
          // Store target for other units to check
          e.targetEnemy = targetEnemy;
          
          if(targetEnemy) {
            // Move towards target enemy
            const dx = targetEnemy.x - e.x;
            const dy = targetEnemy.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * dt;
              e.y += (dy/dist) * e.speed * dt;
            }
            
            // Attack if close enough and heal castle
            if(dist < 30) {
              const damageDealt = e.damage * dt * 2;
              targetEnemy.hp -= damageDealt;
              // Track who killed the enemy for Midas bonus
              if(targetEnemy.hp <= 0) {
                targetEnemy.killedBy = e;
              }
              
              // Heal castle for the damage dealt (with cooldown)
              if(e.healCooldown <= 0) {
                const healAmount = 8; // Enhanced healing for golden angelic
                game.castleHp = Math.min(game.castleHp + healAmount, game.castleMax);
                spawnText(e.x, e.y-20, `+${healAmount}`, '#ffd700', 1.0, 16);
                spawnParticles(e.x, e.y, '#ffd700', 8, 0.6); // Golden healing particles
                e.healCooldown = 0.4; // Faster healing cooldown
              }
              
              spawnParticles(targetEnemy.x, targetEnemy.y, '#ffd700', 3, 0.3);
            }
          } else {
            // No enemies, move towards castle center
            const dx = CENTER.x - e.x;
            const dy = CENTER.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              e.x += (dx/dist) * e.speed * 0.5 * dt;
              e.y += (dy/dist) * e.speed * 0.5 * dt;
            }
          }
          
          // Animation wobble with pulsing golden glow
          e.wobble += dt * 3;
          return;
        }
        
        // Regular enemy behavior
        // Check for nearby taunt units (knights) to attack first (but not for bosses)
        let nearestTaunt = null;
        let tauntDist = Infinity;
        if(e.type !== 'golem' && e.type !== 'dragon') { // Bosses ignore taunt
          for(const other of game.enemies) {
            if(other.taunt && !other.dead && other.type !== 'converted') {
              const dx = other.x - e.x;
              const dy = other.y - e.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              if(dist < tauntDist && dist < 150) { // Attack taunt units within 150 pixels
                tauntDist = dist;
                nearestTaunt = other;
              }
            }
          }
        }
        
        // Check for engineer to attack (but not for bosses)
        let nearestEngineer = null;
        let engineerDist = Infinity;
        if(e.type !== 'golem' && e.type !== 'dragon' && game.centralTower && game.centralTower.engineerActive && game.centralTower.engineerHp > 0) {
          const dx = game.centralTower.engineerX - e.x;
          const dy = game.centralTower.engineerY - e.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if(dist < engineerDist && dist < 120) { // Attack engineer within 120 pixels
            engineerDist = dist;
            nearestEngineer = game.centralTower;
          }
        }
        
        // Move toward castle, taunt units, or engineer
        let targetX = CENTER.x;
        let targetY = CENTER.y;
        if(nearestEngineer) {
          targetX = nearestEngineer.engineerX;
          targetY = nearestEngineer.engineerY;
        } else if(nearestTaunt) {
          targetX = nearestTaunt.x;
          targetY = nearestTaunt.y;
        }
        
        const v = new V2(targetX - e.x, targetY - e.y); 
        const d=v.len(); 
        v.norm(); 
        e.heading = Math.atan2(v.y, v.x);
        
        let speed = e.speed;
        const wallDist = Math.abs(d - CASTLE.r);
        
        // Invisibility (rogues are always invisible now)
        if(e.invisible) e.renderGhost=true; 
        else e.renderGhost=false;
        
        // Knockback decay
        e.vx = (e.vx||0) * Math.pow(0.6, dt*60); 
        e.vy = (e.vy||0) * Math.pow(0.6, dt*60);
        
        // Movement (flyers have different radius, golem stops during slam)
        const targetRadius = e.flyer? CASTLE.r-6 : CASTLE.r- e.radius*0.4;
        if(d > targetRadius && !(e.type === 'golem' && e.isSlamming)){ 
          e.x += v.x * speed * dt + (e.vx||0) * dt; 
          e.y += v.y * speed * dt + (e.vy||0) * dt; 
        }
        
        // Cleric healing
        if(e.type==='cleric'){ 
          e.healTimer = (e.healTimer||0) - dt; 
          if(e.healTimer<=0){ 
            e.healTimer=1.4; 
            for(const f of game.enemies){ 
              if(f.dead||f===e) continue; 
              const dx=f.x-e.x, dy=f.y-e.y; 
              if(dx*dx+dy*dy< 80*80){ 
                f.hp = Math.min(f.maxHp, f.hp + 8); 
                spawnParticles(f.x,f.y,'#88ff00',6,0.5); 
              } 
            } 
          } 
        }
        
        // Wizard necromancy
        if(e.necro){ 
          e.healTimer=(e.healTimer||0)-dt; 
          if(e.healTimer<=0){ 
            e.healTimer=3.0; 
            for(const f of game.enemies){ 
              if(f.dead) { 
                f.dead=false; 
                f.hp=f.maxHp*0.5; 
                spawnParticles(f.x,f.y,'#ff88ff',12,0.8); 
                setBattleMessage('💀 UNDEAD RISES!', 1.5, '#ff8800');
                break; 
              } 
            } 
          } 
        }
        
        // Lancer throws projectiles
        if(e.bomber){ 
          e.throwT=(e.throwT||rand(1.2,2.2))-dt; 
          if(e.throwT<=0){ 
            e.throwT=rand(1.2,2.0); 
            
            // Find nearest cavalry/angelic knight to target, otherwise target castle center
            let targetX = CENTER.x, targetY = CENTER.y;
            let nearestCavalry = null;
            let nearestDist = Infinity;
            
            for(const enemy of game.enemies) {
              if(enemy.dead || enemy.type !== 'cavalry' && enemy.type !== 'angelic' && enemy.type !== 'midas' || enemy.type === 'converted') continue;
              const dx = enemy.x - e.x;
              const dy = enemy.y - e.y;
              const dist = dx*dx + dy*dy;
              if(dist < nearestDist) {
                nearestDist = dist;
                nearestCavalry = enemy;
              }
            }
            
            if(nearestCavalry) {
              targetX = nearestCavalry.x;
              targetY = nearestCavalry.y;
            }
            
            const ang=Math.atan2(targetY-e.y, targetX-e.x); 
            const sp=220; 
            game.eProjectiles.push({ 
              x:e.x, y:e.y, 
              vx:Math.cos(ang)*sp, 
              vy:Math.sin(ang)*sp, // Remove arc, shoot straight
              life:2.2, r:4, 
              color: '#ffff00' 
            }); 
          } 
        }
        
        // Electric moat damage (if spike moat upgrade is active)
        if(game.upgrades.oil > 0 && !e.flyer && e.type !== 'cavalry' && e.type !== 'angelic' && e.type !== 'midas' && e.type !== 'goldenangelic' && e.type !== 'converted') {
          const moatRadius = CASTLE.r + 120; // Much further from castle
          const moatInner = CASTLE.r + 80;
          if(d >= moatInner && d <= moatRadius) {
            // Apply burn damage over time
            if(!e.burnTimer) e.burnTimer = 0;
            e.burnTimer += dt;
            
            const burnDamage = 12 + 8 * game.upgrades.oil; // Base 12 + 8 per level
            const burnTick = 0.5; // Damage every 0.5 seconds
            
            if(e.burnTimer >= burnTick) {
              e.hp -= burnDamage;
              e.burnTimer = 0;
              spawnParticles(e.x, e.y, '#ff6600', 8, 0.6); // Orange burn particles
              spawnText(e.x, e.y - e.radius - 10, `-${burnDamage}`, '#ff6600', 0.8, 14);
            }
            
            // Visual burn effect
            if(Math.random() < 8*dt) {
              spawnParticles(e.x, e.y, '#ff4400', 3, 0.3);
            }
          } else {
            // Clear burn timer when outside moat
            e.burnTimer = 0;
          }
        }
        
        // Poison damage over time
        if(e.poisonStacks && e.poisonStacks > 0) {
          e.poisonTimer = (e.poisonTimer || 0) + dt;
          const poisonTick = 0.5; // Damage every 0.5 seconds
          
          if(e.poisonTimer >= poisonTick) {
            const poisonDamage = e.poisonStacks * game.upgrades.poison; // 1 damage per stack per level
            e.hp -= poisonDamage;
            e.poisonTimer = 0;
            spawnParticles(e.x, e.y, '#00ff00', 4, 0.3); // Green poison particles
            spawnText(e.x, e.y - e.radius - 20, `-${poisonDamage}`, '#00ff00', 0.6, 12);
            
            // Decay poison stacks over time
            if(Math.random() < 0.1) { // 10% chance per tick to lose a stack
              e.poisonStacks = Math.max(0, e.poisonStacks - 1);
            }
          }
        }
        
        // Fire damage over time (Flame Cannon) - applies damage continuously
        if(e.fireStacks && e.fireStacks > 0) {
          e.fireTimer = (e.fireTimer || 0) + dt;
          const fireTick = 0.3; // Damage every 0.3 seconds
          
          // Apply damage immediately when fire stacks are present
          if(e.fireTimer >= fireTick) {
            // Don't damage friendly units with burn effects
            if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') {
              // Just clear the fire stacks for friendly units
              e.fireStacks = 0;
              e.fireTimer = 0;
            } else {
              // Use stackMultiplier from flame cannon upgrade for infinite stacking
              const flameLevel = game.upgrades.flamecannon || 0;
              const stackMultiplier = 5 + flameLevel; // +1 stack multiplier per level
              const fireDamage = e.fireStacks * stackMultiplier; // Damage scales with stacks and level
              e.hp -= fireDamage;
              e.fireTimer = 0;
              e.fireStacks = Math.max(0, e.fireStacks - 1); // Reduce stacks by 1 each tick
              spawnParticles(e.x, e.y, '#ff4400', 6, 0.4); // Orange fire particles
              spawnText(e.x, e.y - e.radius - 25, `-${fireDamage}`, '#ff4400', 0.6, 14);
            }
          }
          
          // Visual fire effect on burning enemies
          if(Math.random() < 0.3) { // 30% chance per frame
            spawnParticles(e.x, e.y, '#ff4400', 2, 0.3);
          }
        }
        
        // Damage castle walls, taunt units, or engineer (but not friendly units)
        if(nearestEngineer && engineerDist < e.radius + 12 && e.type !== 'cavalry' && e.type !== 'angelic' && e.type !== 'midas' && e.type !== 'goldenangelic' && e.type !== 'converted') { // 12 is engineer radius
          // Attack engineer (only hostile enemies)
          nearestEngineer.engineerHp -= e.damage * dt * 2; // High damage rate to engineer
          spawnParticles(nearestEngineer.engineerX, nearestEngineer.engineerY, '#ff0088', 4, 0.4);
          
          // Check if engineer dies
          if(nearestEngineer.engineerHp <= 0) {
            nearestEngineer.engineerHp = 0;
            nearestEngineer.engineerActive = false;
          }
        } else if(nearestTaunt && tauntDist < e.radius + nearestTaunt.radius) {
          // Attack taunt unit
          nearestTaunt.hp -= e.damage * dt * 2; // High damage rate to taunt units
          spawnParticles(nearestTaunt.x, nearestTaunt.y, '#ff0088', 4, 0.4);
        } else if(wallDist < e.radius && !e.flyer){ 
          damageCastle(e.damage*dt*0.5); 
          if(Math.random()<3*dt) spawnParticles(e.x,e.y,'#ff0088',6,0.6); 
        }
        
        // Enhanced Golem behavior - body horror design
        if(e.type === 'golem') {
          // Initialize enhanced golem properties if not set
          if(e.suckCooldown === undefined) e.suckCooldown = 2.0;
          if(e.slamCooldown === undefined) e.slamCooldown = 5.0;
          if(e.limbUnits === undefined) {
            e.limbUnits = {
              leftArm: [],
              rightArm: [],
              leftLeg: [],
              rightLeg: []
            };
          }
          if(e.walkCycle === undefined) e.walkCycle = 0;
          if(e.bodyPulse === undefined) e.bodyPulse = 0;
          if(e.initialSuckComplete === undefined) e.initialSuckComplete = false;
          
          // Update animation timers
          e.walkCycle += dt * 2; // Walking animation
          e.bodyPulse += dt * 3; // Body pulsing
          
          // Initial dramatic absorption on spawn
          if(!e.initialSuckComplete && e.suckCooldown <= 2.0) {
            // Immediately suck in all sacrificial units
            for(const unit of game.enemies) {
              if(unit.isGolemSacrifice && !unit.dead && unit !== e) {
                const dx = unit.x - e.x;
                const dy = unit.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist < 200) { // Large initial suck radius
                  // Animate unit being pulled in
                  unit.x += (-dx/dist) * 300 * dt;
                  unit.y += (-dy/dist) * 300 * dt;
                  
                  if(dist < 30) {
                    // Absorb the unit
                    absorbUnitIntoLimb(e, unit);
                    unit.dead = true;
                    
                    // Heal golem
                    const healAmount = unit.maxHp * 0.5;
                    e.maxHp += healAmount;
                    e.hp = Math.min(e.hp + healAmount, e.maxHp);
                    
                    // Visual effect
                    spawnParticles(e.x, e.y, '#8B4513', 20, 1.0);
                  }
                }
              }
            }
            
            // Check if initial absorption is complete
            const sacrificesLeft = game.enemies.filter(enemy => enemy.isGolemSacrifice && !enemy.dead).length;
            if(sacrificesLeft === 0) {
              e.initialSuckComplete = true;
              setBattleMessage('🗿 GOLEM ABSORBS MINIONS!', 2.0, '#8B4513');
            }
          }
          
          // Regular suck ability
          e.suckCooldown -= dt;
          if(e.suckCooldown <= 0 && e.initialSuckComplete) {
            e.suckCooldown = 3.0;
            
            // Find nearby units to absorb
            for(const unit of game.enemies) {
              if(unit.dead || unit === e) continue;
              if(unit.type === 'cavalry' || unit.type === 'angelic' || unit.type === 'midas' || unit.type === 'goldenangelic' || unit.type === 'converted') continue;
              
              const dx = unit.x - e.x;
              const dy = unit.y - e.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if(dist < 160) {
                // Pull unit towards golem
                unit.x += (-dx/dist) * 200 * dt;
                unit.y += (-dy/dist) * 200 * dt;
                
                if(dist < 30) {
                  // Absorb unit
                  absorbUnitIntoLimb(e, unit);
                  unit.dead = true;
                  
                  // Heal and grow
                  const healAmount = unit.maxHp * 0.5;
                  e.maxHp += healAmount;
                  e.hp = Math.min(e.hp + healAmount, e.maxHp);
                  
                  spawnText(e.x, e.y-e.radius-20, `+${Math.round(healAmount)}`, '#8B4513', 1.0, 18);
                  spawnParticles(e.x, e.y, '#8B4513', 15, 0.8);
                }
              }
            }
          }
          
          // Slam attack
          e.slamCooldown -= dt;
          if(e.slamCooldown <= 0) {
            e.slamCooldown = 5.0;
            e.isSlamming = true;
            
            // Slam effect - stun nearby units
            for(const unit of game.enemies) {
              if(unit.dead) continue;
              if(unit.type === 'cavalry' || unit.type === 'angelic' || unit.type === 'midas' || unit.type === 'goldenangelic' || unit.type === 'converted') {
                const dx = unit.x - e.x;
                const dy = unit.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist < 120) {
                  unit.stunned = true;
                  unit.stunTimer = 2.0;
                  spawnText(unit.x, unit.y-15, 'STUNNED!', '#ff0000', 1.0, 16);
                  spawnParticles(unit.x, unit.y, '#ff0000', 8, 0.6);
                }
              }
            }
            
            setBattleMessage('🗿 GOLEM SLAM!', 2.0, '#8B4513');
            game.shake = Math.min(20, game.shake + 8);
          }
          
          // Reset slamming state
          if(e.isSlamming && e.slamCooldown < 4.5) {
            e.isSlamming = false;
          }
        }
        
        // Helper function to assign units to limbs
        function absorbUnitIntoLimb(golem, unit) {
          // Determine which limb needs units
          const limbs = ['leftArm', 'rightArm', 'leftLeg', 'rightLeg'];
          let targetLimb = null;
          let minCount = Infinity;
          
          // Find the limb with fewest units
          for(const limb of limbs) {
            if(golem.limbUnits[limb].length < minCount) {
              minCount = golem.limbUnits[limb].length;
              targetLimb = limb;
            }
          }
          
          // Add unit to the chosen limb
          if(targetLimb) {
            golem.limbUnits[targetLimb].push({
              type: unit.type,
              color: ENEMY[unit.type].color,
              hp: unit.maxHp,
              offset: Math.random() * Math.PI * 2, // Random rotation offset
              squiggle: Math.random() * Math.PI * 2 // Random squiggle phase
            });
          }
        }
        
        // Animation wobble
        e.wobble += dt * 3;
      }

      function projectileUpdate(p, dt){ 
        p.life-=dt; 
        if(p.life<=0) return false; 
        
        // Trail effect
        p.trail.push({ x:p.x, y:p.y, life:0.25 }); 
        const maxTrailLength = (p.sniper || p.timeSlow) ? 50 : 10; // Much longer trail for sniper and time slow shots
        while(p.trail.length > maxTrailLength) p.trail.shift(); 
        
        // Boomerang return logic
        if(p.boomerang && !p.returnPhase) {
          // Check if projectile should start returning (after 0.8 seconds)
          if(p.life < 0.4) {
            p.returnPhase = true;
            // Calculate direction back to origin
            const dx = p.originX - p.x;
            const dy = p.originY - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              const speed = 540*(1+0.25*game.upgrades.rapid);
              p.vx = (dx/dist) * speed;
              p.vy = (dy/dist) * speed;
            }
          }
        }
        
        p.vx*=0.999; 
        p.vy*=0.999; 
        p.x+=p.vx*dt; 
        p.y+=p.vy*dt;
        
        // Check collisions
        for(const e of game.enemies){ 
          if(e.dead) continue; 
          if(e.invisible) continue; // Invisible enemies are always invisible now
          if(p.hitSet.has(e)) continue; 
          // FRIENDLY UNIT PROTECTION: All friendly units are immune to player/tower damage
          if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue; // Cavalry, angelic knights, midas knights, golden angelic knights, and converted enemies are immune to player/tower damage
          if(p.radiant && (e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted')) continue; // Radiant projectiles also don't damage friendly units
          
          const dx=e.x-p.x, dy=e.y-p.y; 
          const rr = (e.radius+6);
          
          if(dx*dx+dy*dy < rr*rr){ 
            // Shield block check (knights) — shields have HP and can be broken
            if(e.type==='knight' && (e.shieldHp==null || e.shieldHp>0)){ 
              const inAngle = Math.acos( clamp(( (p.vx*-1)*Math.cos(e.heading) + (p.vy*-1)*Math.sin(e.heading) )/(Math.hypot(p.vx,p.vy)||1), -1, 1) ); 
              if(inAngle < e.blockAngle){ 
                // Powershots break through shields
                if(p.powershot) {
                  e.shieldHp = 0;
                  spawnText(e.x, e.y-e.radius-15, 'SHIELD BROKEN!', '#ff00ff', 1.0, 18);
                  spawnParticles(p.x,p.y,'#ff00ff',12,0.8); 
                  sfx.hit(); 
                  // Continue with normal damage to the enemy
                } else {
                  // Hit the shield instead of the body
                  e.shieldHp = (e.shieldHp==null? Math.round(60*DIFFICULTY.ENEMY_HP_MULT) : e.shieldHp) - p.baseDmg*0.8; 
                  spawnParticles(p.x,p.y,'#00ffff',8,0.6); 
                  sfx.hit(); 
                  p.life=0; 
                  if(e.shieldHp<=0){ 
                    // Show "blocked" text above the mob instead of toast
                    spawnText(e.x, e.y-e.radius-15, 'blocked', '#ffffff', 1.2, 16, true);
                  }
                  break; 
                }
              } 
            }
            
            // Hit!
            const dmg = p.baseDmg * (p.crit && Math.random()<0.12? 2.5:1);
            e.hp -= dmg;
            
            // Apply poison damage (stacking)
            if(p.poison && game.upgrades.poison > 0) {
              if(!e.poisonStacks) e.poisonStacks = 0;
              e.poisonStacks = e.poisonStacks + 1; // Infinite stacking
              // Don't reset poison timer - let it continue ticking
              spawnParticles(e.x, e.y, '#00ff00', 6, 0.4); // Green poison particles
            }
            
            // Apply burn damage (Radiant Aegis projectiles)
            if(p.radiant && p.burnStacks) {
              if(!e.fireStacks) e.fireStacks = 0;
              e.fireStacks += p.burnStacks; // Add burn stacks
              e.fireTimer = 0.3; // Start timer immediately so damage ticks right away
              spawnParticles(e.x, e.y, '#ff4400', 8, 0.6); // Orange fire particles
              spawnText(e.x, e.y-12, `+${p.burnStacks}`, '#ff4400', 0.6, 16);
            }
            
            // Knockback (dragon is immune)
            if(e.type !== 'dragon') {
              const kb = new V2(p.vx, p.vy).norm().scale(360*(0.8+Math.random()*0.4)); 
              e.vx += kb.x; 
              e.vy += kb.y;
            }
            
            // Damage text
            spawnText(e.x, e.y-12, `-${Math.round(dmg)}`, p.crit ? '#ff00ff' : '#00ffff', 0.6, p.crit ? 24 : 18);
            spawnParticles(e.x, e.y, e.glowColor, 15, 0.8);
            
            sfx.hit(); 
            game.shake = Math.min(12, game.shake + 3);
            if(p.src==='player'){
              game.combo = Math.min(10, game.combo + 0.3 + (game.upgrades.crit?0.15:0)); 
              game.comboTimer = 1.1;
            }
            
            p.hitSet.add(e);
            
            // Central Tower chaining logic
            if(p.src === 'centraltower' && p.chainCount < p.maxChains) {
              // Add this enemy to chained list
              p.chainedEnemies.push(e);
              
              // Find next enemy to chain to
              let nextEnemy = null;
              let nextDist = Infinity;
              for(const enemy of game.enemies) {
                if(enemy.dead || enemy === e) continue;
                if(enemy.type === 'cavalry' || enemy.type === 'angelic' || enemy.type === 'midas' || enemy.type === 'goldenangelic' || enemy.type === 'converted') continue;
                if(p.chainedEnemies.includes(enemy)) continue; // Don't chain to already hit enemies
                
                const dx = enemy.x - e.x;
                const dy = enemy.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist < p.chainRange && dist < nextDist) {
                  nextDist = dist;
                  nextEnemy = enemy;
                }
              }
              
              if(nextEnemy) {
                // Create chain effect
                const dx = nextEnemy.x - e.x;
                const dy = nextEnemy.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const speed = 800;
                
                // Update projectile to target next enemy
                p.x = e.x;
                p.y = e.y;
                p.vx = (dx/dist) * speed;
                p.vy = (dy/dist) * speed;
                p.chainCount++;
                p.targetEnemy = nextEnemy;
                
                // Visual chain effect
                spawnParticles(e.x, e.y, '#ff1493', 20, 1.0);
                spawnText(e.x, e.y-25, 'CHAIN!', '#ff1493', 0.8, 16);
                
                // Continue projectile life
                p.life = 1.0; // Reset life for chain
                return true;
              }
            }
            
            if(!p.pierce || p.pierce<=0){ 
              p.life=0; 
            } else { 
              p.pierce--; 
            }
            
            if(p.explosive){ 
              explodeAt(e.x, e.y, p.baseDmg*0.7); 
            }
          }
        }
        
        return p.life>0;
      }

      function enemyProjectileUpdate(ep, dt){ 
        ep.life-=dt; 
        if(ep.life<=0) return false; 
        
        // Remove gravity for straight projectile movement
        // ep.vy += 180*dt; 
        ep.x += ep.vx*dt; 
        ep.y += ep.vy*dt; 
        
        // Divine Aegis collision check
        if(game.upgrades.divineaegis > 0 && game.divineAegis.active) {
          const shieldSize = game.divineAegis.size;
          
          // Calculate shield position based on mouse position (same as rendering)
          const dx = mouse.x - CENTER.x;
          const dy = mouse.y - CENTER.y;
          const mouseAngle = Math.atan2(dy, dx);
          
          const shieldDistance = 200; // Same distance as rendering
          const shieldX = CENTER.x + Math.cos(mouseAngle) * shieldDistance;
          const shieldY = CENTER.y + Math.sin(mouseAngle) * shieldDistance;
          
          // Shield faces toward the mouse (perpendicular to the radius)
          const shieldAngle = mouseAngle + Math.PI/2; // Rotate 90 degrees to face mouse
          const offsetAngle = (game.divineAegis.divineAegisAngle||0) * (Math.PI/180);
          const finalShieldAngle = shieldAngle + offsetAngle;
          const halfWidth = shieldSize * 0.8;
          
          // Transform projectile position to shield's local coordinates
          const projDx = ep.x - shieldX;
          const projDy = ep.y - shieldY;
          const rotatedX = projDx * Math.cos(-finalShieldAngle) - projDy * Math.sin(-finalShieldAngle);
          const rotatedY = projDx * Math.sin(-finalShieldAngle) + projDy * Math.cos(-finalShieldAngle);
          
          // Check if projectile is within shield bounds (straight line with slight curve)
          if(Math.abs(rotatedX) <= halfWidth && rotatedY >= -shieldSize * 0.1 && rotatedY <= shieldSize * 0.1) {
            // Shield absorbs the projectile and heals castle
            const healAmount = 8; // Base heal amount (same as projectile damage)
            game.castleHp = Math.min(game.castleHp + healAmount, game.castleMax);
            game.divineAegis.hp -= 5; // Each projectile damages shield
            
            spawnParticles(ep.x, ep.y, '#00ffff', 15, 0.8);
            spawnText(ep.x, ep.y-20, 'HEALED', '#00ff00', 0.8, 16);
            spawnText(ep.x, ep.y-40, `+${healAmount}`, '#00ff00', 0.6, 14);
            
            // Radiant Aegis: Visual effect when absorbing projectiles
            if(game.upgrades.radiantaegis > 0) {
              spawnParticles(shieldX, shieldY, '#ffaa00', 20, 1.0);
              spawnText(shieldX, shieldY-60, 'RADIANT', '#ffaa00', 0.8, 16);
              
              // Create animated fire plume from the shield
              const radiantLevel = game.upgrades.radiantaegis;
              
              // Calculate direction away from the absorbed projectile
              const fireDir = Math.atan2(ep.y - shieldY, ep.x - shieldX);
              const fireRange = 150 + radiantLevel * 25; // Longer range per level
              const plumeWidth = 60 + radiantLevel * 10; // Wider plume per level
              
              // Create main fire plume
              const endX = shieldX + Math.cos(fireDir) * fireRange;
              const endY = shieldY + Math.sin(fireDir) * fireRange;
              
              if(!game.flameStreams) game.flameStreams = [];
              game.flameStreams.push({
                x1: shieldX, y1: shieldY, x2: endX, y2: endY,
                width: plumeWidth,
                life: 0.8, // Longer duration for fire effect
                baseDamage: 1,
                stackMultiplier: 1,
                dir: fireDir,
                range: fireRange,
                fromRadiantAegis: true, // Mark as Radiant Aegis fire
                radiantLevel: radiantLevel
              });
              
              // Create sputtering embers from the edges of the plume
              const sputterCount = 6 + radiantLevel * 2; // More sputters per level
              
              for(let j = 0; j < sputterCount; j++) {
                // Calculate sputter position along the plume edge
                const sputterT = Math.random(); // Random position along plume
                const sputterX = shieldX + (endX - shieldX) * sputterT;
                const sputterY = shieldY + (endY - shieldY) * sputterT;
                
                // Calculate perpendicular direction for outward sputters
                const perpDir = fireDir + Math.PI/2; // Perpendicular to plume direction
                const sputterAngle = perpDir + (Math.random() - 0.5) * 0.6; // Outward spread
                const sputterSpeed = 300 + Math.random() * 200;
                
                if(!game.projectiles) game.projectiles = [];
                game.projectiles.push({
                  x: sputterX,
                  y: sputterY,
                  vx: Math.cos(sputterAngle) * sputterSpeed,
                  vy: Math.sin(sputterAngle) * sputterSpeed,
                  size: 5 + radiantLevel,
                  life: 2.0,
                  baseDmg: 8 + radiantLevel * 2,
                  color: '#ffaa00',
                  src: 'radiantaegis',
                  sputter: true,
                  burnStacks: 1,
                  trail: []
                });
              }
            }
            
            ep.life = 0;
            return false;
          }
        }
        
        // Check collision with taunt units (knights) first
        for(const e of game.enemies) {
          if(e.taunt && !e.dead && e.type !== 'converted') {
            const dx = ep.x - e.x;
            const dy = ep.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < e.radius + 6) { // 6 is projectile radius
              // Damage the knight
              e.hp -= 8; // Same damage as castle
              spawnParticles(ep.x, ep.y, '#ffff00', 12, 0.8);
              spawnText(e.x, e.y-e.radius-10, '-8', '#ffff00', 0.8, 16);
              ep.life = 0;
              return false;
            }
          }
        }
        
        // Check collision with engineer
        if(game.centralTower && game.centralTower.engineerActive && game.centralTower.engineerHp > 0) {
          const dx = ep.x - game.centralTower.engineerX;
          const dy = ep.y - game.centralTower.engineerY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if(dist < 12 + 6) { // Engineer radius + projectile radius
            // Damage the engineer
            game.centralTower.engineerHp -= 8;
            spawnParticles(ep.x, ep.y, '#ffff00', 12, 0.8);
            spawnText(game.centralTower.engineerX, game.centralTower.engineerY-15, '-8', '#ffff00', 0.8, 16);
            ep.life = 0;
            return false;
          }
        }
        
        const dx=ep.x-CENTER.x, dy=ep.y-CENTER.y; 
        const d=Math.hypot(dx,dy); 
        
        if(Math.abs(d-CASTLE.r)<18){ 
          damageCastle(8); 
          spawnParticles(ep.x,ep.y,'#ffff00',12,0.8); 
          ep.life=0; 
          return false; 
        } 
        
        return ep.life>0; 
      }

      function explodeAt(x,y,dmg,radius=120){ 
        spawnParticles(x,y,'#ff00ff',30,1.5); 
        spawnParticles(x,y,'#00ffff',30,1.5);
        game.shake = Math.min(20, game.shake + 8);
        
        for(const e of game.enemies){ 
          if(e.dead) continue; 
          // Don't damage friendly units with explosions
          if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
          const dx=e.x-x,dy=e.y-y; 
          const d2=dx*dx+dy*dy; 
          if(d2<radius*radius){ 
            const d = Math.sqrt(d2)||1; 
            const push = (140/d); 
            // Dragon is immune to knockback
            if(e.type !== 'dragon') {
              e.vx += (dx/d)*push; 
              e.vy += (dy/d)*push; 
            }
            e.hp -= dmg; 
            spawnParticles(e.x,e.y,'#ff8800',8,0.8); 
          } 
        } 
      }

      function damageCastle(amount){ 
        game.castleHp -= amount; 
        if(game.castleHp<=0){ 
          game.castleHp=0; 
          gameOver(); 
        } 
      }

      function applyFortifications(){
        const lvl = game.upgrades.fort||0;
        // Increase max HP and redraw castle scale slightly
        const base = CASTLE.maxHpBase;
        game.castleMax = Math.round(base * (1 + 0.25*lvl));
        const healAmount = 15 + 5*lvl; // Base 15 + 5 per level
        game.castleHp = Math.min(game.castleHp + healAmount, game.castleMax);
        // Visually thicken walls by slightly increasing radius
        CASTLE.r = 140 + Math.min(20, 6*lvl);
      }

      // Game Over overlay and quick restart
      function gameOver(){
        game.state = STATE.OVER;
        game.high = Math.max(game.high, Math.floor(game.score));
        persist();
        // Build Game Over UI in overlay
        ui.ovTitle.innerHTML = '<div class="epic-title">GAME OVER</div>';
        ui.ovSub.textContent = 'Press R to restart, or choose an option';
        ui.ovBody.innerHTML = `
          <div class="card" style="grid-column:1/-1">
            <div class="title">Final Score</div>
            <div class="desc">Score: ${Math.floor(game.score)} · High: ${Math.floor(game.high)}</div>
          </div>
        `;
        const actions = document.createElement('div');
        actions.style.display='flex'; actions.style.gap='10px'; actions.style.gridColumn='1/-1'; actions.style.justifyContent='flex-end';
        const btnRestart = document.createElement('button');
        btnRestart.className='primary';
        btnRestart.textContent = 'Restart (R)';
        btnRestart.addEventListener('click', ()=>{ showOverlay(false); startGame(); });
        const btnMenu = document.createElement('button');
        btnMenu.textContent = 'Main Menu';
        btnMenu.addEventListener('click', ()=>{ buildMenu(); });
        actions.appendChild(btnRestart); actions.appendChild(btnMenu);
        ui.ovBody.appendChild(actions);
        showOverlay(true);
      }

      // Quick restart hotkey
      window.addEventListener('keydown', (e)=>{
        if (game.state === STATE.OVER && e.key.toLowerCase() === 'r') {
          showOverlay(false);
          startGame();
        }
      });

      // ============================
      // Update & Render
      // ============================
      function loop(t){ 
        let dt = Math.min(0.033,(t-game.last)/1000); 
        game.last=t; 
        handleControls(dt); 
        dt *= (game.dtScale||1); 
        
        if(game.state===STATE.PLAY){ 
          update(dt); 
          render(); 
          requestAnimationFrame(loop); 
        } else { 
          render(); 
        } 
        
        updateHUD(); 
      }

      function update(dt){
        handleShooting(dt);
        ballistaThink(dt);
        
        // Radiant Aegis: Simple sputtering (no visuals, no absorption effects)
        if(game.upgrades.divineaegis > 0 && game.divineAegis.active && game.upgrades.radiantaegis > 0) {
          const radiantLevel = game.upgrades.radiantaegis;
          const sputterInterval = 1.5; // Sputter every 1.5 seconds
          
          // Initialize or update sputter timer
          if(!game.radiantSputterTimer) game.radiantSputterTimer = 0;
          game.radiantSputterTimer += dt;
          
          if(game.radiantSputterTimer >= sputterInterval) {
            game.radiantSputterTimer = 0;
            
            // Calculate shield position (same as in collision detection)
            const mouseAngle = Math.atan2(mouse.y - CENTER.y, mouse.x - CENTER.x);
            const shieldDistance = 200; // Same distance as rendering
            const shieldX = CENTER.x + Math.cos(mouseAngle) * shieldDistance;
            const shieldY = CENTER.y + Math.sin(mouseAngle) * shieldDistance;
            
            // Create sputtering projectiles pointing outward from shield center
            for(let i = 0; i < 3; i++) { // 3 sputtering projectiles
              const sputterAngle = mouseAngle + (Math.PI * 2 / 3) * i; // Point outward from shield
              const sputterSpeed = 300 + Math.random() * 200; // Fast sputters
              
              if(!game.projectiles) game.projectiles = [];
              game.projectiles.push({
                x: shieldX,
                y: shieldY,
                vx: Math.cos(sputterAngle) * sputterSpeed,
                vy: Math.sin(sputterAngle) * sputterSpeed,
                size: 5, // Same size as flame cannon sputter
                life: 1.5,
                baseDmg: 6 + radiantLevel * 2, // Damage scales with level
                color: '#ffaa00',
                src: 'radiantaegis',
                sputter: true,
                burnStacks: 1,
                trail: [],
                hitSet: new Set()
              });
            }
          }
        }
        
        game.bgPulse += dt;
        
        // Spawn enemies
        trySpawn(dt);
        
        // Update projectiles
        for(let i=game.projectiles.length-1;i>=0;i--){ 
          const p = game.projectiles[i];
          
          // Handle sputtering projectiles (flame cannon)
          if(p.sputter) {
            p.life -= dt;
            if(p.life <= 0) {
              game.projectiles.splice(i, 1);
              continue;
            }
            
            // Update position
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            
            // Check collision with enemies
            for(const e of game.enemies) {
              if(e.dead || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
              
              const dx = e.x - p.x;
              const dy = e.y - p.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if(dist < e.radius + p.size) {
                // Apply damage and burn stacks
                e.hp -= p.baseDmg;
                if(!e.fireStacks) e.fireStacks = 0;
                e.fireStacks += p.burnStacks;
                e.fireTimer = 0;
                
                // Visual effects
                spawnParticles(e.x, e.y, '#ff4400', 6, 0.4);
                spawnText(e.x, e.y-15, `-${p.baseDmg}`, '#ff0000', 0.6, 14);
                
                // Remove projectile
                game.projectiles.splice(i, 1);
                break;
              }
            }
            continue;
          }
          
          // Handle homing projectiles
          if(p.homing) {
            p.life -= dt;
            if(p.life <= 0) {
              game.projectiles.splice(i, 1);
              continue;
            }
            
            // Find nearest enemy target
            let nearestEnemy = null;
            let nearestDist = Infinity;
            for(const e of game.enemies) {
              if(e.dead || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
              
              const dx = e.x - p.x;
              const dy = e.y - p.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if(dist < nearestDist && dist < 300) { // Only target enemies within 300 pixels
                nearestEnemy = e;
                nearestDist = dist;
              }
            }
            
            // Update target and steering
            if(nearestEnemy) {
              p.target = nearestEnemy;
              
              // Calculate direction to target
              const dx = nearestEnemy.x - p.x;
              const dy = nearestEnemy.y - p.y;
              const targetDir = Math.atan2(dy, dx);
              
              // Current direction
              const currentDir = Math.atan2(p.vy, p.vx);
              
              // Smooth steering (gradual turn)
              let angleDiff = targetDir - currentDir;
              if(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
              if(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
              
              // Limit turn rate
              const maxTurnRate = 2.0; // radians per second
              const turnAmount = Math.max(-maxTurnRate * dt, Math.min(maxTurnRate * dt, angleDiff));
              const newDir = currentDir + turnAmount;
              
              // Accelerate over time
              p.currentSpeed = Math.min(p.maxSpeed, p.currentSpeed + p.acceleration * dt);
              
              // Update velocity
              p.vx = Math.cos(newDir) * p.currentSpeed;
              p.vy = Math.sin(newDir) * p.currentSpeed;
            }
            
            // Update position
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            
            // Add trail effect
            p.trail.push({ x: p.x, y: p.y, life: 0.3 });
            while(p.trail.length > 15) p.trail.shift();
            
            // Check collision with enemies
            for(const e of game.enemies) {
              if(e.dead || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
              
              const dx = e.x - p.x;
              const dy = e.y - p.y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if(dist < e.radius + p.size) {
                // Explode on impact
                explodeAt(p.x, p.y, p.baseDmg, p.explosionRadius);
                
                // Apply poison effect to all enemies in explosion radius
                if(game.upgrades.poison > 0) {
                  for(const enemy of game.enemies) {
                    if(enemy.dead) continue;
                    const dx = enemy.x - p.x;
                    const dy = enemy.y - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if(dist < p.explosionRadius) {
                      // Apply poison stacks
                      if(!enemy.poisonStacks) enemy.poisonStacks = 0;
                      enemy.poisonStacks += game.upgrades.poison;
                      enemy.poisonTimer = 3.0; // Reset poison timer
                      
                      // Visual poison effect
                      spawnText(enemy.x, enemy.y-enemy.radius-10, 'POISON!', '#00ff00', 0.8, 14);
                      spawnParticles(enemy.x, enemy.y, '#00ff00', 6, 0.6);
                    }
                  }
                }
                
                // Visual explosion effect
                spawnParticles(p.x, p.y, '#ff00ff', 40, 1.5);
                spawnParticles(p.x, p.y, '#00ffff', 30, 1.2);
                spawnText(p.x, p.y-20, 'EXPLOSION!', '#ff00ff', 1.0, 18);
                
                // Remove projectile
                game.projectiles.splice(i, 1);
                break;
              }
            }
            continue;
          }
          
          // Regular projectile update
          if(!projectileUpdate(game.projectiles[i], dt)){ 
            game.projectiles.splice(i,1); 
          } 
        }
        
        for(let i=game.eProjectiles.length-1;i>=0;i--){ 
          if(!enemyProjectileUpdate(game.eProjectiles[i], dt)){ 
            game.eProjectiles.splice(i,1); 
          } 
        }
        
        // Update sniper lines
        if(game.sniperLines) {
          for(let i=game.sniperLines.length-1;i>=0;i--){
            game.sniperLines[i].life -= dt;
            if(game.sniperLines[i].life <= 0) {
              game.sniperLines.splice(i,1);
            }
          }
        }
        
        // Update flame streams
        if(game.flameStreams) {
          for(let i=game.flameStreams.length-1;i>=0;i--){
            game.flameStreams[i].life -= dt;
            if(game.flameStreams[i].life <= 0) {
              game.flameStreams.splice(i,1);
            }
          }
        }
        
        // Update orbital strikes
        if(game.orbitalStrikes) {
          for(let i=game.orbitalStrikes.length-1;i>=0;i--){
            const strike = game.orbitalStrikes[i];
            strike.timer -= dt;
            
            if(strike.timer <= 0.001) { // Small buffer for floating point precision
              
              // Execute orbital strike
              const strikeX = strike.x;
              const strikeY = strike.y;
              
              // Massive explosion effect
              spawnParticles(strikeX, strikeY, '#ff0000', 80, 2.0);
              spawnParticles(strikeX, strikeY, '#ffaa00', 60, 1.8);
              spawnParticles(strikeX, strikeY, '#ffff00', 40, 1.5);
              game.shake = Math.min(25, game.shake + 15);
              
              // Damage all enemies in radius
              for(const e of game.enemies) {
                if(e.dead) continue;
                if(e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
                
                const dx = e.x - strikeX;
                const dy = e.y - strikeY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist < strike.radius) {
                  // Apply damage
                  e.hp -= strike.damage;
                  spawnText(e.x, e.y-20, `-${Math.round(strike.damage)}`, '#ff0000', 1.0, 20);
                  spawnParticles(e.x, e.y, '#ff0000', 15, 0.8);
                  
                  // Time Necromancy - convert enemies killed by orbital strike
                  if(e.hp <= 0 && game.upgrades.necromancy > 0) {
                    const necroLevel = game.upgrades.necromancy;
                    const statBonus = 1 + necroLevel * 0.25; // +25% stats per level
                    
                    // Convert the enemy to friendly
                    e.dead = false;
                    e.maxHp = e.maxHp * statBonus;
                    e.hp = e.maxHp; // Set to 100% health after conversion
                    e.damage = e.damage * statBonus;
                    e.speed = e.speed * 1.6; // +60% speed
                    e.originalType = e.type; // Store original type before changing
                    e.type = 'converted';
                    e.color = '#00ff88';
                    e.glowColor = '#00ff88';
                    e.invisible = false; // Ensure they are visible
                    
                    spawnText(e.x, e.y-e.radius-25, 'CONVERTED!', '#00ff88', 1.0, 20);
                    spawnParticles(e.x, e.y, '#00ff88', 30, 1.0);
                    setBattleMessage('💀 ORBITAL CONVERSION!', 2.5, '#00ff88');
                  }
                }
              }
              
              // Battle message
              setBattleMessage('☄️ ORBITAL STRIKE!', 2.0, '#ff0000');
              
              // Remove strike
              game.orbitalStrikes.splice(i,1);
            }
          }
        }
        
        // Update Central Tower and Engineer (Tower of Babel)
        if(game.centralTower && game.centralTower.engineerActive) {
          const tower = game.centralTower;
          
          // Engineer is alive
          if(tower.engineerHp > 0) {
            
            // STATE: COLLECTING RESOURCES
            if(tower.engineerState === 'collecting') {
              // Find nearest uncollected resource
              if(!tower.resourceTarget || tower.resourceTarget.collected) {
                let nearestResource = null;
                let nearestDist = Infinity;
                
                for(const resource of game.resources) {
                  if(resource.collected) continue;
                  
                  // Skip if we have enough of this type
                  if(tower.stonesCollected >= tower.stonesNeeded && resource.type === 'stone') continue;
                  if(tower.woodCollected >= tower.woodNeeded && resource.type === 'wood') continue;
                  
                  const dx = resource.x - tower.engineerX;
                  const dy = resource.y - tower.engineerY;
                  const dist = Math.sqrt(dx*dx + dy*dy);
                  
                  if(dist < nearestDist) {
                    nearestDist = dist;
                    nearestResource = resource;
                  }
                }
                
                tower.resourceTarget = nearestResource;
              }
              
              // Move towards resource
              if(tower.resourceTarget && !tower.carryingResource) {
                const dx = tower.resourceTarget.x - tower.engineerX;
                const dy = tower.resourceTarget.y - tower.engineerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist > 15) {
                  // Move towards resource
                  tower.engineerX += (dx/dist) * tower.engineerSpeed * dt;
                  tower.engineerY += (dy/dist) * tower.engineerSpeed * dt;
                } else {
                  // Pick up resource
                  tower.resourceTarget.collected = true;
                  tower.carryingResource = tower.resourceTarget.type;
                  
                  // Visual feedback
                  const color = tower.resourceTarget.type === 'stone' ? '#888888' : '#8B4513';
                  spawnParticles(tower.resourceTarget.x, tower.resourceTarget.y, color, 10, 0.6);
                  spawnText(tower.engineerX, tower.engineerY-20, tower.resourceTarget.type.toUpperCase() + '!', color, 0.8, 14);
                  
                  tower.resourceTarget = null;
                }
              }
              
              // Return to castle with resource
              if(tower.carryingResource) {
                const dx = CENTER.x - tower.engineerX;
                const dy = CENTER.y - tower.engineerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist > 20) {
                  // Move back to castle
                  tower.engineerX += (dx/dist) * tower.engineerSpeed * dt;
                  tower.engineerY += (dy/dist) * tower.engineerSpeed * dt;
                } else {
                  // Deposit resource
                  if(tower.carryingResource === 'stone') {
                    tower.stonesCollected++;
                    spawnText(CENTER.x, CENTER.y-30, `Stone ${tower.stonesCollected}/${tower.stonesNeeded}`, '#888888', 1.0, 16);
                  } else {
                    tower.woodCollected++;
                    spawnText(CENTER.x, CENTER.y-30, `Wood ${tower.woodCollected}/${tower.woodNeeded}`, '#8B4513', 1.0, 16);
                  }
                  
                  tower.carryingResource = null;
                  
                  // Check if ready to build
                  if(tower.stonesCollected >= tower.stonesNeeded && tower.woodCollected >= tower.woodNeeded) {
                    tower.engineerState = 'building';
                    setBattleMessage('🏗️ CONSTRUCTION BEGINS!', 2.5, '#ff1493');
                  }
                }
              }
            }
            
            // STATE: BUILDING TOWER
            else if(tower.engineerState === 'building') {
              // Circle around castle while building
              const time = performance.now() * 0.001;
              const radius = 50;
              const speed = 0.5;
              tower.engineerX = CENTER.x + Math.cos(time * speed) * radius;
              tower.engineerY = CENTER.y + Math.sin(time * speed) * radius;
              
              // Build progress
              tower.lastBuildTime += dt;
              if(tower.lastBuildTime >= tower.buildInterval) {
                tower.lastBuildTime = 0;
                tower.constructionProgress = Math.min(tower.maxProgress, tower.constructionProgress + tower.buildAmount);
                
                // Update visual levels
                const progress = tower.constructionProgress / tower.maxProgress;
                tower.scaffoldHeight = progress;
                tower.towerLevels = Math.floor(progress * tower.maxLevels);
                
                // Visual effect
                spawnParticles(CENTER.x, CENTER.y - 20 * tower.towerLevels, '#ff1493', 12, 0.8);
                spawnText(tower.engineerX, tower.engineerY-15, '+5', '#ff1493', 0.8, 14);
                
                // Check completion
                if(tower.constructionProgress >= tower.maxProgress && !tower.towerBuilt) {
                  tower.towerBuilt = true;
                  tower.engineerState = 'repairing';
                  spawnParticles(CENTER.x, CENTER.y, '#ff1493', 100, 2.0);
                  setBattleMessage('🏰 TOWER OF BABEL COMPLETE!', 3.0, '#ff1493');
                  game.shake = Math.min(20, game.shake + 10);
                }
              }
            }
            
            // STATE: REPAIRING CASTLE
            else if(tower.engineerState === 'repairing') {
              // Circle around castle while repairing
              const time = performance.now() * 0.001;
              const radius = 40;
              const speed = 0.8;
              tower.engineerX = CENTER.x + Math.cos(time * speed) * radius;
              tower.engineerY = CENTER.y + Math.sin(time * speed) * radius;
              
              // Repair castle
              tower.repairTimer += dt;
              if(tower.repairTimer >= tower.repairInterval) {
                tower.repairTimer = 0;
                game.castleHp = Math.min(game.castleHp + tower.repairAmount, game.castleMax);
                
                spawnParticles(CENTER.x, CENTER.y, '#00ff00', 8, 0.6);
                spawnText(tower.engineerX, tower.engineerY-15, `+${tower.repairAmount} HP`, '#00ff00', 1.0, 14);
              }
            }
          } else {
            // Engineer is dead
            tower.engineerActive = false;
            setBattleMessage('💀 ENGINEER KILLED!', 2.5, '#ff0000');
          }
          
          // TOWER LIGHTNING ATTACKS
          if(tower.towerBuilt) {
            tower.lastShotTime += dt;
            if(tower.lastShotTime >= tower.shotInterval) {
              tower.lastShotTime = 0;
              
              // Find nearest enemy
              let nearestEnemy = null;
              let nearestDist = Infinity;
              
              for(const e of game.enemies) {
                if(e.dead || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
                
                const dx = e.x - CENTER.x;
                const dy = e.y - CENTER.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist < tower.range && dist < nearestDist) {
                  nearestDist = dist;
                  nearestEnemy = e;
                }
              }
              
              if(nearestEnemy) {
                // Create lightning bolt
                const bolt = {
                  x1: CENTER.x,
                  y1: CENTER.y - 60, // From tower top
                  x2: nearestEnemy.x,
                  y2: nearestEnemy.y,
                  life: 0.4,
                  segments: [],
                  color: '#ff00ff',
                  thickness: 8
                };
                
                // Generate jagged lightning path
                const segmentCount = 12;
                for(let i = 0; i <= segmentCount; i++) {
                  const t = i / segmentCount;
                  const baseX = bolt.x1 + (bolt.x2 - bolt.x1) * t;
                  const baseY = bolt.y1 + (bolt.y2 - bolt.y1) * t;
                  const offset = (i === 0 || i === segmentCount) ? 0 : (Math.random() - 0.5) * 30;
                  bolt.segments.push({
                    x: baseX + offset,
                    y: baseY + offset * 0.5
                  });
                }
                
                game.lightningBolts.push(bolt);
                
                // Deal damage
                nearestEnemy.hp -= tower.damage;
                spawnText(nearestEnemy.x, nearestEnemy.y-20, `-${tower.damage}`, '#ff00ff', 1.0, 20);
                spawnParticles(nearestEnemy.x, nearestEnemy.y, '#ff00ff', 30, 1.2);
                
                // Find chain target
                let chainEnemy = null;
                let chainDist = Infinity;
                
                for(const e of game.enemies) {
                  if(e.dead || e === nearestEnemy || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
                  
                  const dx = e.x - nearestEnemy.x;
                  const dy = e.y - nearestEnemy.y;
                  const dist = Math.sqrt(dx*dx + dy*dy);
                  
                  if(dist < tower.chainRange && dist < chainDist) {
                    chainDist = dist;
                    chainEnemy = e;
                  }
                }
                
                // Create chain lightning
                if(chainEnemy) {
                  const chainBolt = {
                    x1: nearestEnemy.x,
                    y1: nearestEnemy.y,
                    x2: chainEnemy.x,
                    y2: chainEnemy.y,
                    life: 0.3,
                    segments: [],
                    color: '#8800ff',
                    thickness: 5
                  };
                  
                  // Generate chain path
                  const chainSegments = 8;
                  for(let i = 0; i <= chainSegments; i++) {
                    const t = i / chainSegments;
                    const baseX = chainBolt.x1 + (chainBolt.x2 - chainBolt.x1) * t;
                    const baseY = chainBolt.y1 + (chainBolt.y2 - chainBolt.y1) * t;
                    const offset = (i === 0 || i === chainSegments) ? 0 : (Math.random() - 0.5) * 20;
                    chainBolt.segments.push({
                      x: baseX + offset,
                      y: baseY + offset * 0.5
                    });
                  }
                  
                  game.lightningBolts.push(chainBolt);
                  
                  // Chain damage
                  chainEnemy.hp -= tower.chainDamage;
                  spawnText(chainEnemy.x, chainEnemy.y-20, `-${tower.chainDamage}`, '#8800ff', 1.0, 18);
                  spawnParticles(chainEnemy.x, chainEnemy.y, '#8800ff', 20, 1.0);
                }
                
                // Screen shake and sound
                game.shake = Math.min(15, game.shake + 5);
                sfx.powerup();
              }
            }
          }
        }
        
        // Update lightning bolts
        if(game.lightningBolts) {
          for(let i = game.lightningBolts.length - 1; i >= 0; i--) {
            game.lightningBolts[i].life -= dt;
            if(game.lightningBolts[i].life <= 0) {
              game.lightningBolts.splice(i, 1);
            }
          }
        }
        
        // Update Divine Aegis
        if(game.upgrades.divineaegis > 0) {
          if(game.divineAegis.active && game.divineAegis.hp <= 0) {
            // Shield broken
            game.divineAegis.active = false;
            game.divineAegis.respawnTimer = 15.0; // 15 second respawn
            spawnParticles(game.player.x, game.player.y, '#ff0000', 30, 1.0);
            setBattleMessage('🛡️ DIVINE AEGIS SHATTERED!', 2.5, '#ff0000');
          }
          
          if(!game.divineAegis.active && game.divineAegis.respawnTimer > 0) {
            game.divineAegis.respawnTimer -= dt;
            if(game.divineAegis.respawnTimer <= 0) {
              // Respawn shield
              const level = game.upgrades.divineaegis;
              game.divineAegis.active = true;
              game.divineAegis.hp = game.divineAegis.maxHp;
              spawnParticles(game.player.x, game.player.y, '#00ffff', 30, 1.0);
              setBattleMessage('🛡️ DIVINE AEGIS RESTORED!', 2.0, '#00ffff');
            }
          }
        }
        
        // Update Undead Dragon
        if(game.undeadDragon.active) {
          // Find nearest enemy to attack
          let nearestEnemy = null;
          let nearestDist = Infinity;
          for(const e of game.enemies) {
            if(e.dead || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
            const dx = e.x - game.undeadDragon.x;
            const dy = e.y - game.undeadDragon.y;
            const dist = dx*dx + dy*dy;
            if(dist < nearestDist) {
              nearestDist = dist;
              nearestEnemy = e;
            }
          }
          
          if(nearestEnemy) {
            // Move towards nearest enemy
            const dx = nearestEnemy.x - game.undeadDragon.x;
            const dy = nearestEnemy.y - game.undeadDragon.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              const speed = 43; // Increased from 25 to 43 (70% faster)
              game.undeadDragon.x += (dx/dist) * speed * dt;
              game.undeadDragon.y += (dy/dist) * speed * dt;
            }
            
            // Attack if close enough (much longer range)
            if(dist < 200) { // Increased from 100 to 200 for much longer range
              // Flame cannon attack
              game.undeadDragon.lastFlameTime += dt;
              if(game.undeadDragon.lastFlameTime >= 2.0) { // Attack every 2 seconds
                game.undeadDragon.lastFlameTime = 0;
                
                // Calculate direction to enemy
                const dir = Math.atan2(dy, dx);
                
                // Create flame stream from undead dragon (more triangular)
                const flameRange = 100 + game.undeadDragon.flameLevel * 15; // Longer range
                const flameWidth = 30 + game.undeadDragon.flameLevel * 3; // Narrower base for triangular shape
                const endX = game.undeadDragon.x + Math.cos(dir) * flameRange;
                const endY = game.undeadDragon.y + Math.sin(dir) * flameRange;
                
                // Add flame stream to game state
                if(!game.flameStreams) game.flameStreams = [];
                game.flameStreams.push({
                  x1: game.undeadDragon.x, y1: game.undeadDragon.y, x2: endX, y2: endY,
                  width: flameWidth,
                  life: 0.4,
                  baseDamage: game.undeadDragon.flameLevel,
                  stackMultiplier: game.undeadDragon.flameLevel,
                  dir: dir,
                  range: flameRange,
                  fromUndeadDragon: true
                });
                
                // Create sputtering projectiles from undead dragon
                for(let i = 0; i < 4; i++) { // 4 sputtering projectiles
                  const sputterAngle = dir + (Math.random() - 0.5) * 0.5; // Wider spread
                  const sputterSpeed = 300 + Math.random() * 200; // Fast sputters
                  const sputterX = endX;
                  const sputterY = endY;
                  
                  if(!game.projectiles) game.projectiles = [];
                  game.projectiles.push({
                    x: sputterX,
                    y: sputterY,
                    vx: Math.cos(sputterAngle) * sputterSpeed,
                    vy: Math.sin(sputterAngle) * sputterSpeed,
                    size: 6,
                    life: 1.5,
                    baseDmg: 8,
                    color: '#ffd700',
                    src: 'undeaddragon',
                    sputter: true,
                    burnStacks: 1,
                    trail: []
                  });
                }
                
                // Damage enemies in flame area
                for(const e of game.enemies) {
                  if(e.dead || e.type === 'cavalry' || e.type === 'angelic' || e.type === 'midas' || e.type === 'goldenangelic' || e.type === 'converted') continue;
                  
                  const distToLine = distanceToLine(e.x, e.y, game.undeadDragon.x, game.undeadDragon.y, endX, endY);
                  const distFromStart = Math.sqrt((e.x - game.undeadDragon.x) * (e.x - game.undeadDragon.x) + (e.y - game.undeadDragon.y) * (e.y - game.undeadDragon.y));
                  const coneWidth = flameWidth * (distFromStart / flameRange);
                  const hitRadius = e.radius + coneWidth * 0.5;
                  
                  if(distToLine < hitRadius && distFromStart <= flameRange && distFromStart > 0) {
                    // Apply flamethrower damage (20 + dragon damage)
                    const damage = 20 + game.undeadDragon.damage;
                    e.hp -= damage;
                    spawnText(e.x, e.y-20, `-${damage}`, '#ffd700', 0.8, 16);
                    spawnParticles(e.x, e.y, '#ffd700', 8, 0.6);
                    
                    // Apply burn stacks (1 stack per 0.3 seconds)
                    if(!e.fireStacks) e.fireStacks = 0;
                    e.fireStacks += 1;
                    e.fireTimer = 0.3;
                    
                    // Track kills for the undead dragon
                    if(e.hp <= 0) {
                      game.undeadDragon.kills++;
                      // Make undead dragon stronger with each kill
                      game.undeadDragon.maxHp += 100;
                      game.undeadDragon.hp = Math.min(game.undeadDragon.hp + 100, game.undeadDragon.maxHp);
                      game.undeadDragon.damage += 2;
                      game.undeadDragon.flameLevel += 0.5;
                      
                      // Grant gold to player
                      let goldReward = 10 + game.undeadDragon.kills * 2;
                      if(game.upgrades.midasknights > 0) {
                        goldReward *= (1 + game.upgrades.midasknights * 0.5);
                      }
                      if(game.upgrades.treasury > 0) {
                        goldReward *= (1 + game.upgrades.treasury * 0.5);
                      }
                      game.gold += Math.floor(goldReward);
                      
                      spawnText(game.undeadDragon.x, game.undeadDragon.y-30, `+${Math.floor(goldReward)}g`, '#ffd700', 1.0, 18);
                      spawnText(game.undeadDragon.x, game.undeadDragon.y-50, 'POWER UP!', '#ffffff', 1.0, 16);
                    }
                  }
                }
              }
            }
          } else {
            // No enemies, move towards castle center
            const dx = CENTER.x - game.undeadDragon.x;
            const dy = CENTER.y - game.undeadDragon.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
              const speed = 32; // Increased from 19 to 32 (70% faster)
              game.undeadDragon.x += (dx/dist) * speed * dt;
              game.undeadDragon.y += (dy/dist) * speed * dt;
            }
          }
        }
        
        // Update enemies
        for(let i=game.enemies.length-1;i>=0;i--){ 
          const e=game.enemies[i]; 
          if(e.dead){ continue; } 
          enemyUpdate(e, dt); 
          if(e.hp<=0){ 
            e.dead=true; 
            onEnemyDeath(e); 
            game.enemies.splice(i,1); 
          } 
        }
        
        // Update effects
        for(let i=game.texts.length-1;i>=0;i--){ 
          const a=game.texts[i]; 
          a.life-=dt; 
          a.y+=a.vy*dt;
          a.vy -= 100*dt; 
          if(a.life<=0) game.texts.splice(i,1); 
        }
        
        for(let i=game.particles.length-1;i>=0;i--){ 
          const p=game.particles[i]; 
          p.life-=dt; 
          p.vy+=220*dt; 
          p.x+=p.vx*dt; 
          p.y+=p.vy*dt; 
          if(p.life<=0) game.particles.splice(i,1); 
        }
        
        for(let i=game.coins.length-1;i>=0;i--){ 
          const c=game.coins[i]; 
          c.life-=dt; 
          c.vy+=420*dt; 
          c.x+=c.vx*dt; 
          c.y+=c.vy*dt;
          c.rot += dt * 5; 
          if(c.life<=0) game.coins.splice(i,1); 
        }
        
        // Battle message timer
        if(game.battleMessage.timer > 0) {
          game.battleMessage.timer -= dt;
          if(game.battleMessage.timer <= 0) {
            game.battleMessage.text = '';
            game.battleMessage.color = '#ffffff';
          }
        }
        
        // Combo decay
        if(game.comboTimer>0){ 
          game.comboTimer-=dt; 
          if(game.comboTimer<=0){ 
            game.combo=1; 
          } 
        }
        
        // Check wave completion
        if(allDefeated() && !game._endQueued){
          game._endQueued = true;
          sfx.powerup();
          setBattleMessage('WAVE COMPLETE!', 2.0, '#00ffff');
          setTimeout(()=>{ if(game.state===STATE.PLAY || game.state===STATE.UPGRADE){ endWave(); } game._endQueued=false; }, 1500);
        }
      }

      function onEnemyDeath(e){ 
        const mult = (e.type==='dragon')? 3.0 : 1.0; 
        
        // Epic death effect
        spawnParticles(e.x,e.y, e.glowColor, 30*mult, 1.5); 
        spawnParticles(e.x,e.y,'#ffffff', 20*mult, 1.2);
        spawnCoins(e.x,e.y, Math.round(6*mult)); 
        
        // Check if killed by Midas Knight for bonus gold
        let midasBonus = 1;
        if(e.killedBy && e.killedBy.midas) {
          const midasLevel = game.upgrades.midasknights || 0;
          midasBonus = 2 + midasLevel; // x2 base, +1 per level (x3, x4, x5, etc.)
        }
        
        const goldGain = Math.round((e.reward||6)*(1+0.5*(game.upgrades.treasury||0))*game.combo * midasBonus); 
        game.gold += goldGain; 
        // Track interest for King's Treasury
        if(game.upgrades.treasury > 0) {
          game.treasuryInterest = (game.treasuryInterest || 0) + goldGain * 0.1 * game.upgrades.treasury;
        }
        game.score += (10 + e.reward) * game.combo; 
        
        spawnText(e.x,e.y,'+'+goldGain+'g', '#ffd700', 1.0, 20);
        
        // Special death effects
        if(e.type==='jester' && e.split>0){ 
          for(let i=0;i<2;i++){ 
            const m=makeEnemy('page',1); 
            m.x=e.x+rand(-10,10); 
            m.y=e.y+rand(-10,10); 
            game.enemies.push(m); 
          } 
                      setBattleMessage('JESTER SPLITS!', 1.5, '#ff8800');
        }
        
        if(e.type==='dragon'){
          game.shake = 20;
          showAchievement('DRAGON SLAYER!');
                      setBattleMessage('LEGENDARY KILL!', 3.0, '#ff0088');
        }
        
        sfx.death();
      }

      // Enhanced Golem rendering functions
      function drawEnhancedGolem(ctx, golem, game) {
        const bob = Math.sin(golem.wobble) * 2;
        const walkOffset = Math.sin(golem.walkCycle) * 3;
        const pulseScale = 1 + Math.sin(golem.bodyPulse) * 0.05;
        
        ctx.save();
        
        // Main body shadow
        ctx.shadowColor = '#000000';
        ctx.shadowBlur = 20;
        ctx.shadowOffsetY = 5;
        
        // ROCK BODY - Multiple layers for depth
        const bodyX = golem.x;
        const bodyY = golem.y + bob;
        
        // Outer rock layer
        ctx.fillStyle = '#654321';
        ctx.beginPath();
        ctx.ellipse(bodyX, bodyY, golem.radius * pulseScale, golem.radius * 0.9 * pulseScale, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner rock layer with gradient
        const rockGradient = ctx.createRadialGradient(bodyX, bodyY - 5, 0, bodyX, bodyY, golem.radius);
        rockGradient.addColorStop(0, '#8B4513');
        rockGradient.addColorStop(0.5, '#654321');
        rockGradient.addColorStop(1, '#3E2723');
        
        ctx.fillStyle = rockGradient;
        ctx.beginPath();
        ctx.ellipse(bodyX, bodyY, golem.radius * 0.95 * pulseScale, golem.radius * 0.85 * pulseScale, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Rock cracks and texture
        ctx.strokeStyle = '#3E2723';
        ctx.lineWidth = 2;
        for(let i = 0; i < 6; i++) {
          const angle = (Math.PI * 2 / 6) * i + golem.bodyPulse * 0.1;
          const x1 = bodyX + Math.cos(angle) * golem.radius * 0.3;
          const y1 = bodyY + Math.sin(angle) * golem.radius * 0.3;
          const x2 = bodyX + Math.cos(angle + 0.3) * golem.radius * 0.8;
          const y2 = bodyY + Math.sin(angle + 0.3) * golem.radius * 0.8;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.quadraticCurveTo(
            bodyX + Math.cos(angle + 0.15) * golem.radius * 0.6,
            bodyY + Math.sin(angle + 0.15) * golem.radius * 0.6,
            x2, y2
          );
          ctx.stroke();
        }
        
        // GLOWING EYES
        const eyeGlow = 0.5 + Math.sin(golem.bodyPulse * 2) * 0.5;
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20 * eyeGlow;
        
        // Left eye
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(bodyX - golem.radius * 0.3, bodyY - golem.radius * 0.2, golem.radius * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(bodyX + golem.radius * 0.3, bodyY - golem.radius * 0.2, golem.radius * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye pupils (track player)
        ctx.fillStyle = '#000000';
        const pupilOffset = 3;
        const angleToPlayer = Math.atan2(game.player.y - bodyY, game.player.x - bodyX);
        
        ctx.beginPath();
        ctx.arc(
          bodyX - golem.radius * 0.3 + Math.cos(angleToPlayer) * pupilOffset,
          bodyY - golem.radius * 0.2 + Math.sin(angleToPlayer) * pupilOffset,
          golem.radius * 0.06, 0, Math.PI * 2
        );
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(
          bodyX + golem.radius * 0.3 + Math.cos(angleToPlayer) * pupilOffset,
          bodyY - golem.radius * 0.2 + Math.sin(angleToPlayer) * pupilOffset,
          golem.radius * 0.06, 0, Math.PI * 2
        );
        ctx.fill();
        
        // MOUTH (jagged cave opening)
        ctx.strokeStyle = '#000000';
        ctx.fillStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(bodyX - golem.radius * 0.4, bodyY + golem.radius * 0.1);
        ctx.lineTo(bodyX - golem.radius * 0.2, bodyY + golem.radius * 0.3);
        ctx.lineTo(bodyX, bodyY + golem.radius * 0.2);
        ctx.lineTo(bodyX + golem.radius * 0.2, bodyY + golem.radius * 0.3);
        ctx.lineTo(bodyX + golem.radius * 0.4, bodyY + golem.radius * 0.1);
        ctx.lineTo(bodyX + golem.radius * 0.25, bodyY + golem.radius * 0.15);
        ctx.lineTo(bodyX, bodyY + golem.radius * 0.05);
        ctx.lineTo(bodyX - golem.radius * 0.25, bodyY + golem.radius * 0.15);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        
        // DRAW LIMBS MADE OF ABSORBED UNITS
        drawGolemLimbs(ctx, golem, bodyX, bodyY, walkOffset);
        
        // Draw slam effect
        if(golem.isSlamming && golem.slamCooldown > 4.5) {
          const slamProgress = (5.0 - golem.slamCooldown) / 0.5;
          if(slamProgress <= 1.0) {
            for(let ring = 0; ring < 3; ring++) {
              const ringProgress = Math.max(0, slamProgress - ring * 0.2);
              if(ringProgress > 0) {
                const ringRadius = golem.radius * 2 + ringProgress * 100;
                const alpha = (1 - ringProgress) * 0.6;
                
                ctx.strokeStyle = `rgba(139, 69, 19, ${alpha})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(bodyX, bodyY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
              }
            }
          }
        }
        
        ctx.restore();
        
        // HP Bar
        const hpRatio = golem.hp / golem.maxHp;
        const barWidth = golem.radius * 2.5;
        const barHeight = 6;
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(bodyX - barWidth/2, bodyY - golem.radius - 20, barWidth, barHeight);
        
        ctx.fillStyle = hpRatio > 0.5 ? '#00ff00' : hpRatio > 0.2 ? '#ffff00' : '#ff00ff';
        ctx.fillRect(bodyX - barWidth/2, bodyY - golem.radius - 20, barWidth * hpRatio, barHeight);
        
        // Name
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('GOLEM', bodyX, bodyY + golem.radius + 15);
        
        // Absorbed unit count
        const totalAbsorbed = Object.values(golem.limbUnits).reduce((sum, limb) => sum + limb.length, 0);
        if(totalAbsorbed > 0) {
          ctx.fillStyle = '#8B4513';
          ctx.font = 'bold 10px Orbitron';
          ctx.fillText(`[${totalAbsorbed} absorbed]`, bodyX, bodyY + golem.radius + 28);
        }
      }

      // Helper function to draw animated limbs
      function drawGolemLimbs(ctx, golem, bodyX, bodyY, walkOffset) {
        const limbPositions = {
          leftArm: { x: bodyX - golem.radius * 0.8, y: bodyY - golem.radius * 0.1, angle: -Math.PI/3 },
          rightArm: { x: bodyX + golem.radius * 0.8, y: bodyY - golem.radius * 0.1, angle: Math.PI/3 },
          leftLeg: { x: bodyX - golem.radius * 0.4, y: bodyY + golem.radius * 0.7, angle: -Math.PI/2 },
          rightLeg: { x: bodyX + golem.radius * 0.4, y: bodyY + golem.radius * 0.7, angle: -Math.PI/2 }
        };
        
        // Draw each limb
        for(const [limbName, units] of Object.entries(golem.limbUnits)) {
          if(units.length === 0) continue;
          
          const limbPos = limbPositions[limbName];
          const isArm = limbName.includes('Arm');
          const isLeft = limbName.includes('left');
          
          // Animate limb movement
          let limbAngle = limbPos.angle;
          if(isArm) {
            // Arms swing
            limbAngle += Math.sin(golem.walkCycle + (isLeft ? 0 : Math.PI)) * 0.3;
          } else {
            // Legs step
            limbAngle += Math.sin(golem.walkCycle * 2 + (isLeft ? 0 : Math.PI)) * 0.2;
          }
          
          // Draw squiggly connection to body
          ctx.strokeStyle = '#3E2723';
          ctx.lineWidth = 8;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(limbPos.x, limbPos.y);
          
          // Create squiggly path
          const segments = 5;
          for(let i = 1; i <= segments; i++) {
            const t = i / segments;
            const baseX = limbPos.x + Math.cos(limbAngle) * (30 * t);
            const baseY = limbPos.y + Math.sin(limbAngle) * (30 * t);
            const squiggleX = baseX + Math.sin(golem.walkCycle * 3 + i) * 5;
            const squiggleY = baseY + Math.cos(golem.walkCycle * 3 + i) * 5;
            ctx.lineTo(squiggleX, squiggleY);
          }
          ctx.stroke();
          
          // Draw absorbed units as part of the limb
          units.forEach((unit, index) => {
            const t = (index + 1) / (units.length + 1); // Position along limb
            const unitX = limbPos.x + Math.cos(limbAngle) * (40 * t + 20);
            const unitY = limbPos.y + Math.sin(limbAngle) * (40 * t + 20);
            
            // Squiggle animation for each unit
            const squiggleAmount = 3;
            const squiggleX = unitX + Math.sin(golem.walkCycle * 4 + unit.squiggle) * squiggleAmount;
            const squiggleY = unitY + Math.cos(golem.walkCycle * 4 + unit.squiggle) * squiggleAmount;
            
            // Draw unit as part of limb
            ctx.fillStyle = unit.color;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            // Unit body (smaller than normal)
            ctx.beginPath();
            ctx.arc(squiggleX, squiggleY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Unit details (simplified)
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(squiggleX - 2, squiggleY - 2, 1.5, 0, Math.PI * 2);
            ctx.arc(squiggleX + 2, squiggleY - 2, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Connecting tissue
            if(index < units.length - 1) {
              ctx.strokeStyle = 'rgba(139, 69, 19, 0.5)';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(squiggleX, squiggleY);
              const nextT = (index + 2) / (units.length + 1);
              const nextX = limbPos.x + Math.cos(limbAngle) * (40 * nextT + 20);
              const nextY = limbPos.y + Math.sin(limbAngle) * (40 * nextT + 20);
              ctx.lineTo(nextX + Math.sin(golem.walkCycle * 4 + units[index + 1].squiggle) * squiggleAmount,
                        nextY + Math.cos(golem.walkCycle * 4 + units[index + 1].squiggle) * squiggleAmount);
              ctx.stroke();
            }
          });
        }
      }

      function render(dt=0.016){
        // Clear
        ctx.clearRect(0,0,W,H);
        
        // Screen shake
        if(game.shake>0){ 
          game.shake = Math.max(0, game.shake-0.8); 
          const sx=rand(-game.shake, game.shake), sy=rand(-game.shake, game.shake); 
          ctx.save(); 
          ctx.translate(sx, sy); 
          drawWorld(); 
          ctx.restore(); 
        } else { 
          drawWorld(); 
        }
        
        drawUIFX(dt);
      }

      function drawWorld(){
        // Animated neon background
        const pulse = Math.sin(game.bgPulse) * 0.5 + 0.5;
        const g = ctx.createRadialGradient(CENTER.x,CENTER.y,60, CENTER.x,CENTER.y, 520); 
        g.addColorStop(0,`rgba(255,0,255,${0.1*pulse})`); 
        g.addColorStop(0.5,`rgba(0,255,255,${0.05*pulse})`); 
        g.addColorStop(1,'#0a0014'); 
        ctx.fillStyle=g; 
        ctx.fillRect(0,0,W,H);
        
        // Grid lines for cyberpunk effect
        ctx.strokeStyle = `rgba(255,0,255,${0.1*pulse})`;
        ctx.lineWidth = 1;
        for(let i=0;i<W;i+=50){
          ctx.beginPath();
          ctx.moveTo(i,0);
          ctx.lineTo(i,H);
          ctx.stroke();
        }
        for(let i=0;i<H;i+=50){
          ctx.beginPath();
          ctx.moveTo(0,i);
          ctx.lineTo(W,i);
          ctx.stroke();
        }
        
        // Castle with neon glow
        const hpR = clamp(game.castleHp/game.castleMax,0,1);
        
        // Castle outer glow
        ctx.shadowColor = hpR>0.6? '#00ffff' : hpR>0.3? '#ffff00' : '#ff00ff';
        ctx.shadowBlur = 30;
        ctx.strokeStyle = hpR>0.6? '#00ffff' : hpR>0.3? '#ffff00' : '#ff00ff';
        ctx.lineWidth=4; 
        ctx.beginPath(); 
        ctx.arc(CENTER.x,CENTER.y,CASTLE.r+10,0,Math.PI*2); 
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Castle walls
        ctx.strokeStyle = hpR>0.6? '#00cccc' : hpR>0.3? '#cccc00' : '#cc00cc';
        ctx.lineWidth=18; 
        ctx.beginPath(); 
        ctx.arc(CENTER.x,CENTER.y,CASTLE.r,0,Math.PI*2); 
        ctx.stroke();
        
        // Castle keep (interior)
        const g2 = ctx.createRadialGradient(CENTER.x,CENTER.y,0, CENTER.x,CENTER.y,CASTLE.r-26);
        g2.addColorStop(0,'#1a0033');
        g2.addColorStop(1,'#0a0014');
        ctx.fillStyle = g2; 
        ctx.beginPath(); 
        ctx.arc(CENTER.x, CENTER.y, CASTLE.r-26, 0, Math.PI*2); 
        ctx.fill();
        
                // Electric moat effect (if spike moat upgrade is active)
        if(game.upgrades.oil > 0) {
          const time = performance.now() * 0.003;
          const level = game.upgrades.oil;
          
          // Draw multiple electric rings based on upgrade level
          for(let ring = 0; ring < level; ring++) {
            const ringRadius = Math.max(10, CASTLE.r + 80 + ring * 15); // Rings get further apart, prevent negative radius
            const intensity = 1 - (ring * 0.2); // Inner rings are brighter
            
            // Electric halo effect
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 20 * intensity;
            ctx.strokeStyle = `rgba(255, 102, 0, ${0.8 * intensity})`;
            ctx.lineWidth = 4 * intensity;
            
            // Draw electric arcs around the ring
            const arcCount = 8 + ring * 2; // More arcs for higher levels
            for(let i = 0; i < arcCount; i++) {
              const startAngle = (i / arcCount) * Math.PI * 2 + time;
              const endAngle = ((i + 1) / arcCount) * Math.PI * 2 + time;
              const arcLength = (endAngle - startAngle) * 0.7; // Leave gaps
              
              ctx.beginPath();
              ctx.arc(CENTER.x, CENTER.y, ringRadius, startAngle, startAngle + arcLength);
              ctx.stroke();
              
              // Add electric sparks at the ends
              const sparkX1 = CENTER.x + Math.cos(startAngle) * ringRadius;
              const sparkY1 = CENTER.y + Math.sin(startAngle) * ringRadius;
              const sparkX2 = CENTER.x + Math.cos(startAngle + arcLength) * ringRadius;
              const sparkY2 = CENTER.y + Math.sin(startAngle + arcLength) * ringRadius;
              
              ctx.shadowBlur = 15 * intensity;
              ctx.fillStyle = `rgba(255, 255, 0, ${intensity})`;
              ctx.beginPath();
              ctx.arc(sparkX1, sparkY1, Math.max(0.1, 3 * intensity), 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(sparkX2, sparkY2, Math.max(0.1, 3 * intensity), 0, Math.PI * 2);
              ctx.fill();
            }
            
            // Add pulsing energy waves
            const pulseRadius = Math.max(10, ringRadius + Math.sin(time * 2 + ring) * 5);
            ctx.shadowBlur = 10 * intensity;
            ctx.strokeStyle = `rgba(255, 200, 0, ${0.3 * intensity})`;
            ctx.lineWidth = 2 * intensity;
            ctx.beginPath();
            ctx.arc(CENTER.x, CENTER.y, pulseRadius, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          ctx.shadowBlur = 0;
        }
        
        // Draw wall indicators
        // Wall positions removed - no longer needed with mouse-based movement
        
        // Projectile trails
        for(const p of game.projectiles){ 
          // Skip trail rendering for sputtering projectiles
          if(p.sputter) continue;
          
          const gradient = ctx.createLinearGradient(p.x-10, p.y, p.x+10, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(0.5, p.color);
          gradient.addColorStop(1, 'transparent');
          ctx.strokeStyle=gradient; 
          ctx.lineWidth=3; 
          ctx.beginPath(); 
          let first=true; 
          for(const t of p.trail){ 
            if(first){ 
              ctx.moveTo(t.x,t.y); 
              first=false; 
            } else { 
              ctx.lineTo(t.x,t.y); 
            } 
          } 
          ctx.stroke(); 
        }
        
        // Sniper lines
        if(game.sniperLines) {
          for(const line of game.sniperLines) {
            const alpha = clamp(line.life / 0.3, 0, 1);
            ctx.globalAlpha = alpha;
            const color = line.isTimeSlow ? '#ffff00' : '#ff00ff'; // Yellow for time slow, magenta for sniper upgrade
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.strokeStyle = color;
            ctx.lineWidth = line.width || 6;
            ctx.beginPath();
            ctx.moveTo(line.x1, line.y1);
            ctx.lineTo(line.x2, line.y2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
        
        // Orbital Strike indicators
        if(game.orbitalStrikes) {
          for(const strike of game.orbitalStrikes) {
            const progress = 1 - (strike.timer / strike.totalDelay);
            const alpha = 0.3 + progress * 0.7;
            
            ctx.globalAlpha = alpha;
            
            // Draw warning circle
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(strike.x, strike.y, strike.radius * progress, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw crosshair
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(strike.x - 20, strike.y);
            ctx.lineTo(strike.x + 20, strike.y);
            ctx.moveTo(strike.x, strike.y - 20);
            ctx.lineTo(strike.x, strike.y + 20);
            ctx.stroke();
            
            // Draw countdown text
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.fillText(`${strike.timer.toFixed(1)}s`, strike.x, strike.y - 40);
            
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
        
        // Central Tower and Engineer (Tower of Babel)
        if(game.centralTower) {
          const tower = game.centralTower;
          
          // Draw resources on map
          if(game.resources) {
            for(const resource of game.resources) {
              if(resource.collected) continue;
              
              if(resource.type === 'stone') {
                // Draw stone
                ctx.fillStyle = '#888888';
                ctx.shadowColor = '#888888';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(resource.x, resource.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Stone texture
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.arc(resource.x - 2, resource.y - 2, 3, 0, Math.PI * 2);
                ctx.fill();
              } else {
                // Draw wood
                ctx.fillStyle = '#8B4513';
                ctx.shadowColor = '#8B4513';
                ctx.shadowBlur = 10;
                ctx.fillRect(resource.x - 6, resource.y - 8, 12, 16);
                
                // Wood grain
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(resource.x - 4, resource.y - 6);
                ctx.lineTo(resource.x - 4, resource.y + 6);
                ctx.moveTo(resource.x, resource.y - 6);
                ctx.lineTo(resource.x, resource.y + 6);
                ctx.stroke();
              }
              ctx.shadowBlur = 0;
            }
          }
          
          // Draw tower construction or completed tower
          if(!tower.towerBuilt) {
            // Draw scaffolding during construction
            const progress = tower.constructionProgress / tower.maxProgress;
            const levels = Math.floor(progress * tower.maxLevels);
            
            ctx.strokeStyle = '#ff1493';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff1493';
            ctx.shadowBlur = 15;
            
            // Base platform
            const baseWidth = 80;
            const baseHeight = 15;
            ctx.fillStyle = 'rgba(255, 20, 147, 0.3)';
            ctx.fillRect(CENTER.x - baseWidth/2, CENTER.y - baseHeight/2, baseWidth, baseHeight);
            ctx.strokeRect(CENTER.x - baseWidth/2, CENTER.y - baseHeight/2, baseWidth, baseHeight);
            
            // Build levels (Tower of Babel style - pyramidal)
            for(let level = 0; level < levels; level++) {
              const levelY = CENTER.y - 15 - level * 20;
              const levelWidth = baseWidth - level * 10;
              const levelHeight = 18;
              
              // Level platform
              ctx.fillStyle = `rgba(255, 20, 147, ${0.3 - level * 0.03})`;
              ctx.fillRect(CENTER.x - levelWidth/2, levelY - levelHeight/2, levelWidth, levelHeight);
              ctx.strokeRect(CENTER.x - levelWidth/2, levelY - levelHeight/2, levelWidth, levelHeight);
              
              // Spiral scaffolding
              const spiralAngle = (level * Math.PI / 3) + (performance.now() * 0.0005);
              for(let i = 0; i < 4; i++) {
                const angle = spiralAngle + (i * Math.PI / 2);
                const sx = CENTER.x + Math.cos(angle) * (levelWidth/2 + 10);
                const sy = levelY + Math.sin(angle) * 8;
                
                ctx.beginPath();
                ctx.moveTo(CENTER.x - levelWidth/2, levelY);
                ctx.lineTo(sx, sy);
                ctx.stroke();
              }
            }
            
            // Progress bar
            const barWidth = 100;
            const barHeight = 8;
            const barX = CENTER.x - barWidth/2;
            const barY = CENTER.y - 60 - levels * 20;
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#ff1493';
            ctx.fillRect(barX, barY, barWidth * progress, barHeight);
            
            ctx.fillStyle = '#ff1493';
            ctx.font = 'bold 14px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.round(progress * 100)}%`, CENTER.x, barY - 15);
            
            // Resource counter
            if(tower.engineerState === 'collecting') {
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 12px Orbitron';
              ctx.fillText(`Stone: ${tower.stonesCollected}/${tower.stonesNeeded}`, CENTER.x - 40, CENTER.y + 40);
              ctx.fillText(`Wood: ${tower.woodCollected}/${tower.woodNeeded}`, CENTER.x + 40, CENTER.y + 40);
            }
            
          } else {
            // Draw completed Tower of Babel
            const pulseIntensity = Math.sin(performance.now() * 0.004) * 0.3 + 0.7;
            
            ctx.fillStyle = '#ff1493';
            ctx.shadowColor = '#ff1493';
            ctx.shadowBlur = 25 * pulseIntensity;
            
            // Draw all 7 levels
            for(let level = 0; level < tower.maxLevels; level++) {
              const levelY = CENTER.y - 15 - level * 20;
              const levelWidth = 80 - level * 10;
              const levelHeight = 18;
              
              // Gradient for each level
              const gradient = ctx.createLinearGradient(
                CENTER.x - levelWidth/2, levelY,
                CENTER.x + levelWidth/2, levelY
              );
              gradient.addColorStop(0, '#ff1493');
              gradient.addColorStop(0.5, '#ffffff');
              gradient.addColorStop(1, '#ff1493');
              
              ctx.fillStyle = gradient;
              ctx.fillRect(CENTER.x - levelWidth/2, levelY - levelHeight/2, levelWidth, levelHeight);
              
              // Level borders
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(CENTER.x - levelWidth/2, levelY - levelHeight/2, levelWidth, levelHeight);
              
              // Windows on each level
              ctx.fillStyle = '#000000';
              for(let i = 0; i < 3; i++) {
                if(levelWidth > 30) {
                  const windowX = CENTER.x - levelWidth/2 + 10 + i * (levelWidth/4);
                  const windowY = levelY;
                  ctx.fillRect(windowX, windowY - 4, 6, 8);
                }
              }
              
              // Floating energy orbs
              const orbAngle = performance.now() * 0.002 + level * Math.PI / 4;
              const orbX = CENTER.x + Math.cos(orbAngle) * (levelWidth/2 + 15);
              const orbY = levelY + Math.sin(orbAngle) * 5;
              
              ctx.fillStyle = '#ffffff';
              ctx.shadowColor = '#ffffff';
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.arc(orbX, orbY, 4, 0, Math.PI * 2);
              ctx.fill();
            }
            
            // Tower spire with lightning rod
            const spireY = CENTER.y - 15 - tower.maxLevels * 20;
            ctx.fillStyle = '#ff1493';
            ctx.beginPath();
            ctx.moveTo(CENTER.x, spireY - 10);
            ctx.lineTo(CENTER.x - 8, spireY - 35);
            ctx.lineTo(CENTER.x, spireY - 50);
            ctx.lineTo(CENTER.x + 8, spireY - 35);
            ctx.closePath();
            ctx.fill();
            
            // Lightning rod
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(CENTER.x, spireY - 50);
            ctx.lineTo(CENTER.x, spireY - 65);
            ctx.stroke();
            
            // Energy ball (pulses when firing)
            const energySize = tower.lastShotTime < 0.2 ? 12 : 8;
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(CENTER.x, spireY - 65, energySize, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.shadowBlur = 0;
          
          // Draw engineer
          if(tower.engineerActive && tower.engineerHp > 0) {
            ctx.fillStyle = '#ff1493';
            ctx.shadowColor = '#ff1493';
            ctx.shadowBlur = 10;
            
            // Engineer body
            ctx.beginPath();
            ctx.arc(tower.engineerX, tower.engineerY, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Hard hat
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(tower.engineerX, tower.engineerY - 8, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Show carried resource
            if(tower.carryingResource) {
              ctx.fillStyle = tower.carryingResource === 'stone' ? '#888888' : '#8B4513';
              ctx.fillRect(tower.engineerX + 8, tower.engineerY - 4, 8, 8);
            }
            
            // Health bar
            const healthBarWidth = 24;
            const healthBarHeight = 4;
            const healthBarX = tower.engineerX - healthBarWidth/2;
            const healthBarY = tower.engineerY - 25;
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
            
            const healthPercent = tower.engineerHp / tower.engineerMaxHp;
            ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);
            
            ctx.shadowBlur = 0;
          }
          
          // Draw lightning bolts
          if(game.lightningBolts) {
            for(const bolt of game.lightningBolts) {
              const alpha = Math.min(1, bolt.life / 0.4);
              
              ctx.globalAlpha = alpha;
              ctx.strokeStyle = bolt.color;
              ctx.lineWidth = bolt.thickness;
              ctx.shadowColor = bolt.color;
              ctx.shadowBlur = 20;
              
              // Draw jagged lightning path
              ctx.beginPath();
              if(bolt.segments && bolt.segments.length > 0) {
                ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);
                for(let i = 1; i < bolt.segments.length; i++) {
                  ctx.lineTo(bolt.segments[i].x, bolt.segments[i].y);
                }
              }
              ctx.stroke();
              
              // Extra glow layer
              ctx.lineWidth = bolt.thickness * 0.5;
              ctx.strokeStyle = '#ffffff';
              ctx.shadowBlur = 30;
              ctx.stroke();
              
              ctx.shadowBlur = 0;
              ctx.globalAlpha = 1;
            }
          }
        }
        
        // Flame streams
        if(game.flameStreams) {
          for(const flame of game.flameStreams) {
            const alpha = clamp(flame.life / 0.3, 0, 1);
            ctx.globalAlpha = alpha;
            
            // Special rendering for Radiant Aegis fire streams
            if(flame.fromRadiantAegis) {
              // Create a fire plume effect with stacked and overlapped flames
              const pulseIntensity = Math.sin(game.bgPulse * 12) * 0.3 + 0.7;
              const plumeScale = 1.0 + flame.radiantLevel * 0.2;
              
              // Draw multiple overlapping flame layers to create a dense plume
              for(let layer = 0; layer < 3; layer++) { // 3 overlapping layers
                for(let i = 0; i < 12; i++) { // More flame elements per layer
                  const t = i / 11;
                  const px = flame.x1 + (flame.x2 - flame.x1) * t;
                  const py = flame.y1 + (flame.y2 - flame.y1) * t;
                  
                  // Vary flame size and position for natural overlap
                  const flameSize = (flame.width || 60) * (1 - t * 0.3) * plumeScale * (0.8 + layer * 0.2);
                  const offsetX = (Math.random() - 0.5) * flameSize * 0.3;
                  const offsetY = (Math.random() - 0.5) * flameSize * 0.3;
                  
                  ctx.save();
                  ctx.translate(px + offsetX, py + offsetY);
                  ctx.scale(flameSize / 60, flameSize / 60);
                  
                  // Animated flame effect with varying intensity
                  const flameAlpha = alpha * (0.6 + Math.sin(game.bgPulse * 8 + i * 3 + layer * 2) * 0.3);
                  
                  // Main flame body (orange-red) - larger and more prominent
                  ctx.shadowColor = '#ff4400';
                  ctx.shadowBlur = 20 * pulseIntensity;
                  ctx.fillStyle = `rgba(255, 68, 0, ${flameAlpha * 0.8})`;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.quadraticCurveTo(-4, -15, -7, -25);
                  ctx.quadraticCurveTo(-3, -20, 0, -30);
                  ctx.quadraticCurveTo(3, -20, 7, -25);
                  ctx.quadraticCurveTo(4, -15, 0, 0);
                  ctx.fill();
                  
                  // Inner flame (yellow-orange)
                  ctx.shadowBlur = 15 * pulseIntensity;
                  ctx.fillStyle = `rgba(255, 128, 0, ${flameAlpha * 0.9})`;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.quadraticCurveTo(-3, -12, -5, -20);
                  ctx.quadraticCurveTo(-2, -16, 0, -24);
                  ctx.quadraticCurveTo(2, -16, 5, -20);
                  ctx.quadraticCurveTo(3, -12, 0, 0);
                  ctx.fill();
                  
                  // Flame core (white-hot)
                  ctx.shadowBlur = 8 * pulseIntensity;
                  ctx.fillStyle = `rgba(255, 255, 255, ${flameAlpha * 0.8})`;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.quadraticCurveTo(-1, -8, -2, -15);
                  ctx.quadraticCurveTo(-1, -12, 0, -18);
                  ctx.quadraticCurveTo(1, -12, 2, -15);
                  ctx.quadraticCurveTo(1, -8, 0, 0);
                  ctx.fill();
                  
                  ctx.restore();
                }
              }
              
              // Add floating embers around the plume
              for(let i = 0; i < 8; i++) {
                const t = Math.random();
                const px = flame.x1 + (flame.x2 - flame.x1) * t;
                const py = flame.y1 + (flame.y2 - flame.y1) * t;
                const perpX = Math.cos(flame.dir + Math.PI/2) * (Math.random() - 0.5) * (flame.width || 60) * 0.4;
                const perpY = Math.sin(flame.dir + Math.PI/2) * (Math.random() - 0.5) * (flame.width || 60) * 0.4;
                
                const emberSize = 2 + Math.random() * 3;
                const emberAlpha = alpha * (0.4 + Math.sin(game.bgPulse * 10 + i * 2) * 0.3);
                
                ctx.fillStyle = `rgba(255, 200, 0, ${emberAlpha})`;
                ctx.beginPath();
                ctx.arc(px + perpX, py + perpY, emberSize, 0, Math.PI * 2);
                ctx.fill();
              }
            } else {
              // Regular flame cannon effect
              // Create fire-like gradient
              const gradient = ctx.createLinearGradient(flame.x1, flame.y1, flame.x2, flame.y2);
              gradient.addColorStop(0, '#ff8800'); // Orange at start
              gradient.addColorStop(0.3, '#ff4400'); // Red-orange
              gradient.addColorStop(0.7, '#ff2200'); // Dark red
              gradient.addColorStop(1, '#ff0000'); // Red at end
              
              ctx.shadowColor = '#ff4400';
              ctx.shadowBlur = 30;
              ctx.strokeStyle = gradient;
              
              // Draw multiple lines for fire effect
              for(let i = 0; i < 3; i++) {
                const offset = (i - 1) * 2; // Slight offset for each line
                const perpX = Math.cos(flame.dir + Math.PI/2) * offset;
                const perpY = Math.sin(flame.dir + Math.PI/2) * offset;
                
                ctx.lineWidth = (flame.width || 40) * (1 - i * 0.2); // Decreasing width
                ctx.beginPath();
                ctx.moveTo(flame.x1 + perpX, flame.y1 + perpY);
                ctx.lineTo(flame.x2 + perpX, flame.y2 + perpY);
                ctx.stroke();
              }
              
              // Add fire particles
              for(let i = 0; i < 5; i++) {
                const t = Math.random();
                const px = flame.x1 + (flame.x2 - flame.x1) * t;
                const py = flame.y1 + (flame.y2 - flame.y1) * t;
                const perpX = Math.cos(flame.dir + Math.PI/2) * (Math.random() - 0.5) * flame.width * 0.3;
                const perpY = Math.sin(flame.dir + Math.PI/2) * (Math.random() - 0.5) * flame.width * 0.3;
                
                ctx.fillStyle = `rgba(255, ${Math.floor(200 + Math.random() * 55)}, 0, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(px + perpX, py + perpY, Math.random() * 3 + 1, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          }
        }
        
        // Projectiles with glow
        for(const p of game.projectiles){ 
          // Special glow for homing projectiles
          if(p.homing) {
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 20 + Math.sin(game.bgPulse * 8) * 10; // Pulsing glow
          }
          // Special rendering for sputtering projectiles
          if(p.sputter) {
            // Fading effect based on life
            const alpha = clamp(p.life / 1.0, 0, 1);
            ctx.globalAlpha = alpha;
            
            // Red fire particle with glow
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
            
            // Add small orange core
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ff4400';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 0.6, 0, Math.PI*2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
            continue;
          }
          
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 20;
          ctx.fillStyle=p.color; 
          ctx.beginPath(); 
          ctx.arc(p.x,p.y, p.size, 0, Math.PI*2); 
          ctx.fill();
          ctx.shadowBlur = 0;
        }
        
        // Enemy projectiles
        for(const ep of game.eProjectiles){ 
          ctx.shadowColor = ep.color;
          ctx.shadowBlur = 15;
          ctx.fillStyle=ep.color; 
          ctx.beginPath(); 
          ctx.arc(ep.x,ep.y, ep.r, 0, Math.PI*2); 
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        // Draw enemies with medieval sprites
        for(const e of game.enemies){ 
          if(e.dead) continue; 
          drawEnemy(e); 
        }

        // Player hero with crown
        drawHero(game.player.x, game.player.y);
        

        
        // Divine Aegis shield (upgrades to Radiant Aegis when purchased)
        if(game.upgrades.divineaegis > 0 && game.divineAegis.active) {
          const shieldSize = game.divineAegis.size;
          const shieldHpRatio = game.divineAegis.hp / game.divineAegis.maxHp;
          const isRadiant = game.upgrades.radiantaegis > 0;
          
          // Calculate angle from castle center to mouse position
          const dx = mouse.x - CENTER.x;
          const dy = mouse.y - CENTER.y;
          const mouseAngle = Math.atan2(dy, dx);
          
          // Position shield at a fixed distance from castle center, facing mouse direction
          const shieldDistance = 200; // Distance from castle center
          const shieldX = CENTER.x + Math.cos(mouseAngle) * shieldDistance;
          const shieldY = CENTER.y + Math.sin(mouseAngle) * shieldDistance;
          
          // Shield faces toward the mouse (perpendicular to the radius)
          const shieldAngle = mouseAngle + Math.PI/2; // Rotate 90 degrees to face mouse
          
          // Shield glow effect - red for Radiant Aegis, white for regular
          ctx.shadowColor = isRadiant ? '#ff0000' : '#ffffff';
          ctx.shadowBlur = isRadiant ? 60 : 30; // Increased glow for Radiant Aegis
          
          // Straight shield with slight curve
          ctx.save();
          ctx.translate(shieldX, shieldY);
          const offsetAngle = (game.divineAegis.divineAegisAngle||0) * (Math.PI/180);
          const finalShieldAngle = shieldAngle + offsetAngle;
          ctx.rotate(finalShieldAngle);
          
          // Shield border - straight line with slight curve
          let borderColor = '#ffffff';
          if(isRadiant) {
            // Radiant Aegis: Glowing red hot border with intense pulsing effect
            const pulseIntensity = Math.sin(game.bgPulse * 12) * 0.4 + 0.8; // More intense pulsing
            borderColor = `rgba(255, 0, 0, ${pulseIntensity})`;
          } else {
            borderColor = shieldHpRatio > 0.6 ? '#ffffff' : shieldHpRatio > 0.3 ? '#ffff00' : '#ff0000';
          }
          
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = isRadiant ? 8 : 4; // Even thicker border for Radiant Aegis
          ctx.beginPath();
          
          // Draw a straight line with slight curve for more protective area
          const curveAmount = 0.1; // Slight curve
          const halfWidth = shieldSize * 0.8; // Make it wider than tall
          
          ctx.moveTo(-halfWidth, 0);
          // Add slight curve using quadratic curve - curve downward toward center
          ctx.quadraticCurveTo(0, -shieldSize * curveAmount, halfWidth, 0);
          
          ctx.stroke();
          
          // Radiant Aegis: Add animated fire effects along the shield (always visible)
          if(isRadiant) {
            const radiantLevel = game.upgrades.radiantaegis;
            const flameCount = 2 + radiantLevel; // Fewer but more detailed flames per level
            
            for(let i = 0; i < flameCount; i++) {
              const flamePos = (i / (flameCount - 1)) * 2 - 1; // -1 to 1 across shield
              const flameX = flamePos * halfWidth * 0.8;
              const flameY = -shieldSize * curveAmount * 0.5;
              const flameScale = 0.3 + radiantLevel * 0.1; // Scale based on level
              
              // Create animated fire effect using SVG-style paths
              ctx.save();
              ctx.translate(flameX, flameY);
              ctx.scale(flameScale, flameScale);
              
              // Animated flame effect with pulsing
              const pulseIntensity = Math.sin(game.bgPulse * 8 + i * 2) * 0.3 + 0.7;
              const flameAlpha = Math.sin(game.bgPulse * 15 + i * 3) * 0.2 + 0.8;
              
              // Main flame body (orange-red)
              ctx.shadowColor = '#ff4400';
              ctx.shadowBlur = 15 * pulseIntensity;
              ctx.fillStyle = `rgba(255, 68, 0, ${flameAlpha})`;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.quadraticCurveTo(-5, -15, -8, -25);
              ctx.quadraticCurveTo(-3, -20, 0, -30);
              ctx.quadraticCurveTo(3, -20, 8, -25);
              ctx.quadraticCurveTo(5, -15, 0, 0);
              ctx.fill();
              
              // Inner flame (yellow-orange)
              ctx.shadowBlur = 10 * pulseIntensity;
              ctx.fillStyle = `rgba(255, 128, 0, ${flameAlpha * 0.9})`;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.quadraticCurveTo(-3, -12, -5, -20);
              ctx.quadraticCurveTo(-2, -16, 0, -24);
              ctx.quadraticCurveTo(2, -16, 5, -20);
              ctx.quadraticCurveTo(3, -12, 0, 0);
              ctx.fill();
              
              // Flame core (white-hot)
              ctx.shadowBlur = 5 * pulseIntensity;
              ctx.fillStyle = `rgba(255, 255, 255, ${flameAlpha * 0.7})`;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.quadraticCurveTo(-1, -8, -2, -15);
              ctx.quadraticCurveTo(-1, -12, 0, -18);
              ctx.quadraticCurveTo(1, -12, 2, -15);
              ctx.quadraticCurveTo(1, -8, 0, 0);
              ctx.fill();
              
              // Add floating embers
              for(let j = 0; j < 3; j++) {
                const emberX = (Math.random() - 0.5) * 20;
                const emberY = -Math.random() * 30 - 10;
                const emberSize = 1 + Math.random() * 2;
                const emberAlpha = Math.sin(game.bgPulse * 10 + j * 2) * 0.3 + 0.4;
                
                ctx.fillStyle = `rgba(255, 200, 0, ${emberAlpha})`;
                ctx.beginPath();
                ctx.arc(emberX, emberY, emberSize, 0, Math.PI * 2);
                ctx.fill();
              }
              
              ctx.restore();
            }
          }
          
          // Health indicator - overlay on the same shield (only for non-Radiant Aegis)
          if(shieldHpRatio < 1.0 && !isRadiant) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const healthWidth = halfWidth * shieldHpRatio;
            ctx.moveTo(-halfWidth, 0);
            ctx.quadraticCurveTo(-halfWidth + healthWidth * 0.5, -shieldSize * curveAmount * shieldHpRatio, -halfWidth + healthWidth, 0);
            
            ctx.stroke();
          }
          
          ctx.restore();
          ctx.shadowBlur = 0;
        }

        // Particles with glow
        for(const p of game.particles){ 
          ctx.globalAlpha = clamp(p.life*2,0,1); 
          if(p.glow){
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 10;
          }
          ctx.fillStyle=p.color; 
          ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size); 
          ctx.shadowBlur = 0;
          ctx.globalAlpha=1; 
        }
        
        // Coins spinning
        for(const c of game.coins){ 
          ctx.globalAlpha = clamp(c.life,0,1); 
          ctx.save();
          ctx.translate(c.x, c.y);
          ctx.rotate(c.rot);
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 15;
          ctx.fillStyle= '#ffd700'; 
          ctx.beginPath(); 
          const minor = Math.max(0.001, Math.abs(c.size*Math.cos(c.rot)));
          ctx.ellipse(0,0,c.size, minor, 0, 0, Math.PI*2); 
          ctx.fill();
          ctx.restore();
          ctx.shadowBlur = 0;
          ctx.globalAlpha=1; 
        }
        
        // Floating damage texts
        for(const t of game.texts){ 
          ctx.globalAlpha = clamp(t.life/t.total,0,1); 
          ctx.fillStyle=t.color; 
          ctx.font = `${t.italic ? 'italic ' : ''}bold ${Math.round(t.size)}px Orbitron`; 
          ctx.textAlign='center'; 
          ctx.textBaseline='middle';
          ctx.shadowColor = t.color;
          ctx.shadowBlur = 10;
          ctx.fillText(t.text, t.x, t.y); 
          ctx.shadowBlur = 0;
          ctx.globalAlpha=1; 
        }
        
        // Charge indicator
        if(charging && charge > 0){
          ctx.strokeStyle = `rgba(255,0,255,${charge})`;
          ctx.lineWidth = 3 + charge * 7;
          ctx.beginPath();
          ctx.arc(game.player.x, game.player.y, 20 + charge * 30, 0, Math.PI * 2 * charge);
          ctx.stroke();
        }
      }

      function drawEnemy(e){
        const bob = Math.sin(e.wobble) * 2;
        
        // Glow effect
        ctx.shadowColor = e.glowColor;
        ctx.shadowBlur = 20;
        
        // Different sprites for each enemy type
        if(e.type==='squire'){
          // Basic soldier
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          // Sword
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(e.x, e.y+bob-e.radius);
          ctx.lineTo(e.x, e.y+bob+e.radius);
          ctx.stroke();
        } 
        else if(e.type==='knight'){
          // Armored knight with shield
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          // Shield
          ctx.fillStyle='#ffffff'; 
          ctx.beginPath(); 
          ctx.moveTo(e.x,e.y+bob); 
          const a=e.heading; 
          const s= e.radius+6; 
          ctx.lineTo(e.x+Math.cos(a-0.6)*s, e.y+bob+Math.sin(a-0.6)*s); 
          ctx.lineTo(e.x+Math.cos(a+0.6)*s, e.y+bob+Math.sin(a+0.6)*s); 
          ctx.closePath(); 
          ctx.fill();
        } 
        else if(e.type==='rogue'){
          // Sneaky assassin
          ctx.globalAlpha = e.renderGhost? 0.3: 1; 
          ctx.fillStyle=e.color; 
          // Diamond shape
          ctx.beginPath();
          ctx.moveTo(e.x, e.y+bob-e.radius);
          ctx.lineTo(e.x+e.radius, e.y+bob);
          ctx.lineTo(e.x, e.y+bob+e.radius);
          ctx.lineTo(e.x-e.radius, e.y+bob);
          ctx.closePath();
          ctx.fill(); 
          ctx.globalAlpha=1;
        } 
        else if(e.type==='lancer'){
          // Rectangle with lance
          ctx.fillStyle=e.color; 
          ctx.fillRect(e.x-e.radius*0.9, e.y+bob-e.radius*0.9, e.radius*1.8, e.radius*1.8);
          // Lance pointing forward
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4;
          ctx.beginPath();
          const lanceDir = e.heading;
          ctx.moveTo(e.x, e.y+bob);
          ctx.lineTo(e.x + Math.cos(lanceDir)*e.radius*2, e.y+bob + Math.sin(lanceDir)*e.radius*2);
          ctx.stroke();
        } 
        else if(e.type==='pegasus'){
          // Flying horse - triangle with wings
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.moveTo(e.x, e.y+bob-e.radius); 
          ctx.lineTo(e.x+e.radius, e.y+bob+e.radius); 
          ctx.lineTo(e.x-e.radius, e.y+bob+e.radius); 
          ctx.closePath(); 
          ctx.fill();
          // Wings
          ctx.strokeStyle = e.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(e.x-e.radius, e.y+bob);
          ctx.lineTo(e.x-e.radius*2, e.y+bob-e.radius/2);
          ctx.moveTo(e.x+e.radius, e.y+bob);
          ctx.lineTo(e.x+e.radius*2, e.y+bob-e.radius/2);
          ctx.stroke();
        } 
        else if(e.type==='cleric'){
          // Healer with cross
          ctx.fillStyle=e.color; 
          ctx.fillRect(e.x-e.radius*0.9, e.y+bob-e.radius*0.9, e.radius*1.8, e.radius*1.8);
          // Cross symbol
          ctx.fillStyle='#ffffff';
          ctx.fillRect(e.x-2, e.y+bob-8, 4, 16);
          ctx.fillRect(e.x-8, e.y+bob-2, 16, 4);
        } 
        else if(e.type==='wizard'){
          // Necromancer with star
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill(); 
          // Magic star
          ctx.strokeStyle='#ffffff';
          ctx.lineWidth = 2;
          for(let i=0;i<5;i++){
            const a = (Math.PI*2/5)*i - Math.PI/2;
            const x = e.x + Math.cos(a)*e.radius*0.7;
            const y = e.y+bob + Math.sin(a)*e.radius*0.7;
            if(i===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.closePath();
          ctx.stroke();
        } 
        else if(e.type==='jester'){
          // Jester that splits
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill(); 
          // Jester hat points
          ctx.fillStyle='#ffffff'; 
          for(let i=0;i<3;i++){
            const a = (Math.PI*2/3)*i;
            ctx.beginPath();
            ctx.arc(e.x+Math.cos(a)*e.radius*0.7, e.y+bob+Math.sin(a)*e.radius*0.7, 3, 0, Math.PI*2);
            ctx.fill();
          }
        }
        else if(e.type==='page'){
          // Small minion
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
        }
        else if(e.type==='dragon'){
          // Boss dragon
          ctx.fillStyle=e.color; 
          // Body
          ctx.fillRect(e.x-e.radius*1.3, e.y+bob-e.radius, e.radius*2.6, e.radius*2.0);
          // Wings
          ctx.beginPath();
          ctx.moveTo(e.x-e.radius*1.3, e.y+bob);
          ctx.lineTo(e.x-e.radius*2.5, e.y+bob-e.radius*1.5);
          ctx.lineTo(e.x-e.radius*1.3, e.y+bob-e.radius);
          ctx.moveTo(e.x+e.radius*1.3, e.y+bob);
          ctx.lineTo(e.x+e.radius*2.5, e.y+bob-e.radius*1.5);
          ctx.lineTo(e.x+e.radius*1.3, e.y+bob-e.radius);
          ctx.fill();
          // Fire breath effect
          if(Math.random() < 0.1){
            spawnParticles(e.x, e.y+bob, '#ff8800', 3, 0.5);
          }
        }
        else if(e.type==='golem'){
          // Enhanced Golem with body horror design
          drawEnhancedGolem(ctx, e, game);
        }
        else if(e.type==='cavalry'){
          // Friendly cavalry knight
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          // Sword
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(e.x, e.y+bob-e.radius);
          ctx.lineTo(e.x, e.y+bob+e.radius);
          ctx.stroke();
          // Helmet
          ctx.fillStyle='#ffffff';
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.3, e.radius*0.4, 0, Math.PI*2);
          ctx.fill();
        }
        else if(e.type==='angelic'){
          // Angelic knight with pulsing black/white glow
          const pulseIntensity = Math.sin(game.bgPulse * 8) * 0.3 + 0.7; // Pulsing effect
          
          // Pulsing white glow
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur = 20 * pulseIntensity;
          
          // Main body - black with white border
          ctx.fillStyle = '#000000'; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          
          // White border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2);
          ctx.stroke();
          
          // Angelic sword with white glow
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4;
          ctx.shadowBlur = 10 * pulseIntensity;
          ctx.beginPath();
          ctx.moveTo(e.x, e.y+bob-e.radius);
          ctx.lineTo(e.x, e.y+bob+e.radius);
          ctx.stroke();
          
          // Angelic helmet with glow
          ctx.fillStyle='#ffffff';
          ctx.shadowBlur = 15 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.3, e.radius*0.4, 0, Math.PI*2);
          ctx.fill();
          
          // Angelic halo
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.shadowBlur = 8 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.8, e.radius*0.6, 0, Math.PI*2);
          ctx.stroke();
        }
        else if(e.type==='midas'){
          // Midas knight with pulsing golden glow
          const pulseIntensity = Math.sin(game.bgPulse * 6) * 0.4 + 0.6; // Pulsing effect
          
          // Pulsing golden glow
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 25 * pulseIntensity;
          
          // Main body - golden
          ctx.fillStyle = '#ffd700'; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          
          // White border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2);
          ctx.stroke();
          
          // Golden sword with glow
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4;
          ctx.shadowBlur = 12 * pulseIntensity;
          ctx.beginPath();
          ctx.moveTo(e.x, e.y+bob-e.radius);
          ctx.lineTo(e.x, e.y+bob+e.radius);
          ctx.stroke();
          
          // Golden helmet with glow
          ctx.fillStyle='#ffffff';
          ctx.shadowBlur = 18 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.3, e.radius*0.4, 0, Math.PI*2);
          ctx.fill();
          
          // Golden crown
          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 3;
          ctx.shadowBlur = 10 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.6, e.radius*0.5, 0, Math.PI*2);
          ctx.stroke();
        }
        else if(e.type==='goldenangelic'){
          // Golden Angelic knight with enhanced pulsing golden glow and larger halo
          const pulseIntensity = Math.sin(game.bgPulse * 8) * 0.5 + 0.5; // Enhanced pulsing effect
          
          // Pulsing golden glow
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 35 * pulseIntensity;
          
          // Main body - golden with white border
          ctx.fillStyle = '#ffd700'; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          
          // White border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2);
          ctx.stroke();
          
          // Golden sword with enhanced glow
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 5;
          ctx.shadowBlur = 15 * pulseIntensity;
          ctx.beginPath();
          ctx.moveTo(e.x, e.y+bob-e.radius);
          ctx.lineTo(e.x, e.y+bob+e.radius);
          ctx.stroke();
          
          // Golden helmet with enhanced glow
          ctx.fillStyle='#ffffff';
          ctx.shadowBlur = 20 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.3, e.radius*0.4, 0, Math.PI*2);
          ctx.fill();
          
          // Large golden halo (larger than regular angelic)
          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 4;
          ctx.shadowBlur = 12 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.9, e.radius*0.8, 0, Math.PI*2);
          ctx.stroke();
          
          // Inner white halo
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.shadowBlur = 8 * pulseIntensity;
          ctx.beginPath();
          ctx.arc(e.x, e.y+bob-e.radius*0.9, e.radius*0.7, 0, Math.PI*2);
          ctx.stroke();
        }
        else if(e.type==='converted'){
          // Converted enemy (friendly)
          ctx.fillStyle=e.color; 
          ctx.beginPath(); 
          ctx.arc(e.x,e.y+bob,e.radius,0,Math.PI*2); 
          ctx.fill();
          // Converted symbol (star)
          ctx.strokeStyle='#ffffff';
          ctx.lineWidth = 2;
          for(let i=0;i<5;i++){
            const a = (Math.PI*2/5)*i - Math.PI/2;
            const x = e.x + Math.cos(a)*e.radius*0.7;
            const y = e.y+bob + Math.sin(a)*e.radius*0.7;
            if(i===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.closePath();
          ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        
        // HP bar with glow
        const r = clamp(e.hp/e.maxHp,0,1); 
        const w=e.radius*2,h=4; 
        ctx.fillStyle='rgba(0,0,0,0.5)'; 
        ctx.fillRect(e.x-w/2, e.y-e.radius-12, w, h); 
        ctx.fillStyle=r>0.5?'#00ff00':r>0.2?'#ffff00':'#ff00ff'; 
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 5;
        ctx.fillRect(e.x-w/2, e.y-e.radius-12, w*r, h);
        ctx.shadowBlur = 0;
        
        // Render Undead Dragon
        if(game.undeadDragon.active) {
          const pulseIntensity = Math.sin(game.bgPulse * 6) * 0.4 + 0.6;
          
          // Pulsing black/white glow
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur = 30 * pulseIntensity;
          
          // Main body - black with white border
          ctx.fillStyle = '#000000';
          ctx.fillRect(game.undeadDragon.x-26, game.undeadDragon.y-16, 52, 32);
          
          // White border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.strokeRect(game.undeadDragon.x-26, game.undeadDragon.y-16, 52, 32);
          
          // Wings
          ctx.beginPath();
          ctx.moveTo(game.undeadDragon.x-26, game.undeadDragon.y);
          ctx.lineTo(game.undeadDragon.x-40, game.undeadDragon.y-20);
          ctx.lineTo(game.undeadDragon.x-26, game.undeadDragon.y-16);
          ctx.moveTo(game.undeadDragon.x+26, game.undeadDragon.y);
          ctx.lineTo(game.undeadDragon.x+40, game.undeadDragon.y-20);
          ctx.lineTo(game.undeadDragon.x+26, game.undeadDragon.y-16);
          ctx.fill();
          
          // Undead Dragon HP bar
          const dragonR = clamp(game.undeadDragon.hp/game.undeadDragon.maxHp,0,1);
          const dragonW = 52, dragonH = 6;
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(game.undeadDragon.x-dragonW/2, game.undeadDragon.y-30, dragonW, dragonH);
          ctx.fillStyle = dragonR > 0.5 ? '#00ff00' : dragonR > 0.2 ? '#ffff00' : '#ff00ff';
          ctx.shadowColor = ctx.fillStyle;
          ctx.shadowBlur = 8;
          ctx.fillRect(game.undeadDragon.x-dragonW/2, game.undeadDragon.y-30, dragonW * dragonR, dragonH);
          ctx.shadowBlur = 0;
          
          // Kill counter
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 12px Orbitron';
          ctx.textAlign = 'center';
          ctx.fillText(`${game.undeadDragon.kills} kills`, game.undeadDragon.x, game.undeadDragon.y-40);
        }
        
        // Name label for special enemies
        if(e.type === 'dragon' || e.type === 'wizard' || e.type === 'golem'){
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 10px Orbitron';
          ctx.textAlign = 'center';
          ctx.fillText(ENEMY[e.type].name, e.x, e.y+e.radius+10);
        }
      }

      function drawHero(x,y){
        // Hero with neon crown
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20;
        
        // Body
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI*2);
        ctx.fill();
        
        // Crown
        ctx.fillStyle='#ff00ff'; 
        ctx.beginPath(); 
        ctx.moveTo(x-12,y-6); 
        ctx.lineTo(x-8,y-18); 
        ctx.lineTo(x-2,y-12); 
        ctx.lineTo(x+2,y-20); 
        ctx.lineTo(x+8,y-12); 
        ctx.lineTo(x+12,y-18); 
        ctx.lineTo(x+12,y-6); 
        ctx.closePath(); 
        ctx.fill();
        
        // Bow
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, 18, -Math.PI/3, Math.PI/3);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
      }

      function drawUIFX(dt=0.016){ 
        // Time slow visual effect
        if(game.dtScale < 1) {
          const timeSlowAlpha = 0.1 + Math.sin(game.bgPulse * 3) * 0.05;
          ctx.fillStyle = `rgba(255, 255, 0, ${timeSlowAlpha})`;
          ctx.fillRect(0, 0, W, H);
        }
        
        // Low HP warning
        const hpR = clamp(game.castleHp/game.castleMax,0,1); 
        if(hpR<0.35){ 
          const v = ctx.createRadialGradient(CENTER.x,CENTER.y,120, CENTER.x,CENTER.y, 560); 
          v.addColorStop(0,'rgba(0,0,0,0)'); 
          v.addColorStop(1,`rgba(255,0,136,${0.2 + Math.sin(game.bgPulse*4)*0.1})`); 
          ctx.fillStyle=v; 
          ctx.fillRect(0,0,W,H); 
        }
        
        // Stamina bar (neon style) - moved to bottom center
        const barWidth = 140;
        const barHeight = 10;
        const barX = W/2 - barWidth/2;
        const barY = H - 40;
        
        // Background
        ctx.fillStyle='rgba(0,0,0,0.5)'; 
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Border
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Fill with gradient
        const gradient = ctx.createLinearGradient(barX, 0, barX + barWidth*game.stamina, 0);
        gradient.addColorStop(0, '#00ffff');
        gradient.addColorStop(1, '#ff00ff');
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY, barWidth*game.stamina, barHeight);
        
        // Glow effect
        if(game.stamina < 0.3){
          ctx.shadowColor = '#ff00ff';
          ctx.shadowBlur = 10;
          ctx.strokeStyle = '#ff00ff';
          ctx.strokeRect(barX-1, barY-1, barWidth+2, barHeight+2);
          ctx.shadowBlur = 0;
        }
        
        // Combo indicator - handles all message types with different colors
        let messageText = '';
        let messageColor = '#ff00ff';
        let messageSize = 20;
        let messageGlow = 20;
        
        // Battle message priority (highest priority)
        if(game.battleMessage.timer > 0) {
          messageText = game.battleMessage.text;
          messageColor = game.battleMessage.color;
          messageSize = 24;
          messageGlow = 25;
        }
        // Power shot indicator
        else if(game.powerShotReady) {
          messageText = '⚡ POWER SHOT!';
          messageColor = '#ff00ff';
          messageSize = 22;
          messageGlow = 22;
        } else if(game.dtScale < 1 && game.sniperReloadTimer > 0) {
          messageText = `RELOADING ${game.sniperReloadTimer.toFixed(1)}s`;
          messageColor = '#ffff00';
          messageSize = 18;
          messageGlow = 18;
        } else if(game.dtScale < 1) {
          messageText = 'TIME SLOW';
          messageColor = '#ffff00';
          messageSize = 18;
          messageGlow = 18;
        } else if(game.upgrades.sniper > 0 && game.sniperReloadTimer > 0) {
          messageText = `RELOADING ${game.sniperReloadTimer.toFixed(1)}s`;
          messageColor = '#ff00ff';
          messageSize = 18;
          messageGlow = 18;
        } else if(game.upgrades.divineaegis > 0 && !game.divineAegis.active && game.divineAegis.respawnTimer > 0) {
          messageText = `🛡️ AEGIS ${game.divineAegis.respawnTimer.toFixed(1)}s`;
          messageColor = '#ff0000';
          messageSize = 18;
          messageGlow = 18;
        } else if(game.teleportCooldown > 0) {
          messageText = `⚡ TELEPORT ${game.teleportCooldown.toFixed(1)}s`;
          messageColor = '#00ffff';
          messageSize = 18;
          messageGlow = 18;
        } else if(game.combo > 1.5) {
          messageText = `COMBO x${game.combo.toFixed(1)}!`;
          messageColor = '#ff00ff';
          messageSize = 20 + game.combo * 2;
          messageGlow = 20;
        }
        
        // Display the message if we have one
        if(messageText) {
          const alpha = game.battleMessage.timer > 0 ? 1.0 : Math.sin(game.bgPulse*8)*0.5+0.5;
          ctx.fillStyle = messageColor.replace('#', 'rgba(').replace(')', `,${alpha})`);
          ctx.font = `bold ${messageSize}px Orbitron`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = messageColor;
          ctx.shadowBlur = messageGlow;
          ctx.fillText(messageText, W/2, 100);
          ctx.shadowBlur = 0;
        }
        
        // Cavalry Cooldown display with bar (separate from combo indicator)
        if(game.upgrades.cavalry > 0) {
          const maxCooldown = 10.0;
          const remainingCooldown = Math.max(0, game.cavalryTimer);
          const cooldownProgress = 1 - (remainingCooldown / maxCooldown);
          
          // Draw cooldown bar
          const barWidth = 200;
          const barHeight = 8;
          const barX = W/2 - barWidth/2;
          const barY = 130;
          
          // Bar background
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          // Bar border
          ctx.strokeStyle = '#00ff88';
          ctx.lineWidth = 2;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
          
          // Bar fill
          const fillWidth = barWidth * cooldownProgress;
          if(fillWidth > 0) {
            ctx.fillStyle = remainingCooldown <= 0 ? 
              'linear-gradient(90deg, #00ff88, #00ffff)' : 
              '#00ff88';
            ctx.fillRect(barX, barY, fillWidth, barHeight);
          }
          
          // Cooldown text
          const cooldownText = remainingCooldown <= 0 ? 'CAVALRY READY!' : `CAVALRY: ${remainingCooldown.toFixed(1)}s`;
          const cooldownColor = remainingCooldown <= 0 ? '#00ff88' : '#ffffff';
          const cooldownSize = 14;
          
          ctx.fillStyle = cooldownColor;
          ctx.font = `bold ${cooldownSize}px Orbitron`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = cooldownColor;
          ctx.shadowBlur = 10;
          ctx.fillText(cooldownText, W/2, barY + barHeight + 20); // Position below the bar
          ctx.shadowBlur = 0;
        }

        // Draw active ballista tower shapes
        const lvl = game.upgrades.ballista||0;
        if(lvl>0){
          const angles = [ 
            -Math.PI/2,  // 0 N
             Math.PI/2,  // 1 S
             0,          // 2 E
             Math.PI,    // 3 W
            -Math.PI/4,  // 4 NE
             Math.PI/4,  // 5 SE
             3*Math.PI/4,// 6 SW
            -3*Math.PI/4 // 7 NW
          ];
          const order = [2,3,0,1,4,5,6,7];
          const activeCount = Math.min(lvl, (lvl>4?8:4));
          for(let k=0;k<activeCount;k++){
            const i=order[k];
            const pos = V2.fromAngle(angles[i], CASTLE.r+8);
            const x = CENTER.x+pos.x, y=CENTER.y+pos.y;
            
            // Get target for this turret
            const origin = { x: x, y: y };
            const target = getNearestEnemy(origin);
            let targetAngle = angles[i]; // Default angle
            
            // If there's a target, calculate angle to face it
            if(target) {
              targetAngle = Math.atan2(target.y - origin.y, target.x - origin.x);
            }
            
            // Smooth rotation towards target
            // Ensure turretAngles supports up to 8 slots
            if(game.turretAngles.length < (lvl>4?8:4)){
              const needed = (lvl>4?8:4) - game.turretAngles.length;
              for(let n=0;n<needed;n++) game.turretAngles.push(angles[game.turretAngles.length%angles.length]);
            }
            const currentAngle = game.turretAngles[i]||angles[i];
            const angleDiff = targetAngle - currentAngle;
            
            // Normalize angle difference to shortest path
            let normalizedDiff = angleDiff;
            while(normalizedDiff > Math.PI) normalizedDiff -= Math.PI * 2;
            while(normalizedDiff < -Math.PI) normalizedDiff += Math.PI * 2;
            
            // Smooth rotation speed
            const rotationSpeed = 3.0; // radians per second
            const newAngle = currentAngle + normalizedDiff * Math.min(1, rotationSpeed * dt);
            game.turretAngles[i] = newAngle;
            
            const turretAngle = newAngle;
            
            // Enhanced neon turret design
            ctx.save();
            ctx.translate(x,y);
            ctx.rotate(turretAngle);
            
            // Outer glow
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 15;
            
            // Turret base (hexagonal)
            ctx.fillStyle = 'rgba(255,0,255,0.2)';
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let j=0;j<6;j++){
              const a = (Math.PI/3)*j;
              const px = Math.cos(a)*10;
              const py = Math.sin(a)*10;
              if(j===0) ctx.moveTo(px,py);
              else ctx.lineTo(px,py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Turret body (tall rectangle with neon accents)
            ctx.fillStyle = 'rgba(255,0,255,0.3)';
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-6,-15,12,20);
            ctx.fill();
            ctx.stroke();
            
            // Neon energy core
            ctx.fillStyle = '#ff00ff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(0,-5,3,0,Math.PI*2);
            ctx.fill();
            
            // Turret cannon (pointing right so rotation works correctly)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(15,0);
            ctx.lineTo(25,0);
            ctx.stroke();
            
            // Cannon tip glow
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(25,0,2,0,Math.PI*2);
            ctx.fill();
            
            // Decorative neon rings
            ctx.shadowBlur = 5;
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 1;
            for(let ring=0;ring<2;ring++){
              ctx.beginPath();
              ctx.arc(0,0,8-ring*3,0,Math.PI*2);
              ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
            
            // Firing flash effect - just a small burst at the cannon tip
            if(ballistaThink._flash && ballistaThink._flash[i]>0){
              ctx.shadowColor = '#ffffff';
              ctx.shadowBlur = 15;
              ctx.fillStyle = 'rgba(255,255,255,0.8)';
              ctx.beginPath();
              ctx.arc(25,0,4,0,Math.PI*2);
              ctx.fill();
              ctx.shadowBlur = 0;
            }
          }
        }
      }

      function updateHUD(){ 
        ui.wave.textContent = (game.state===STATE.UPGRADE? game.wave-1 : game.wave).toString(); 
        ui.gold.textContent = Math.floor(game.gold).toString(); 
        // Show interest if King's Treasury is purchased
        if(game.upgrades.treasury > 0) {
          ui.interest.style.display = 'block';
          ui.interestValue.textContent = Math.floor(game.treasuryInterest || 0).toString();
        } else {
          ui.interest.style.display = 'none';
        }
        ui.hptext.textContent = `${Math.ceil(game.castleHp)}/${game.castleMax}`; 
        ui.score.textContent = Math.floor(game.score).toString(); 
        ui.high.textContent = Math.floor(game.high).toString(); 
        ui.combo.textContent = `x${game.combo.toFixed(1)}`;
        
        const r = clamp(game.castleHp/game.castleMax,0,1); 
        ui.hpbar.style.width = `${240*r}px`; 
        ui.hpbar.style.background = r>0.5? 'linear-gradient(90deg,#00ff00,#00ffff)': r>0.2? 'linear-gradient(90deg,#ffff00,#ff8800)': 'linear-gradient(90deg,#ff00ff,#ff0088)';
      }
      
      function previewWaveString(){ 
        const c = {}; 
        (game.nextWave||[]).forEach(s=> c[s.type]=(c[s.type]||0)+1 ); 
        return Object.entries(c).map(([k,v])=>`${ENEMY[k].name}:${v}`).join(' · '); 
      }

      // ============================
      // UI Events
      // ============================
      function byId(id){ return document.getElementById(id); }
      

      
      ui.btnPause.addEventListener('click', ()=>{ 
        sfx.ui(); 
        togglePause(); 
      });
      
      ui.btnReset.addEventListener('click', ()=>{ 
        sfx.ui(); 
        try{ localStorage.removeItem(SAVE_KEY);}catch{} 
        location.reload(); 
      });
      
      ui.btnContinue.addEventListener('click', ()=>{ 
        sfx.ui(); 
        showOverlay(false); 
        
        // Hide intel box when battle starts
        const intelBox = document.getElementById('intelBox');
        if(intelBox) {
          intelBox.style.display = 'none';
          intelBox.style.top = '-200px';
        }
        
        // Check if it's the very first wave (Wave 1)
        if (game.wave === 1) {
          startGame(); // Mimic the Start button behavior
        } else {
          game.state=STATE.PLAY; 
          game.last=performance.now(); 
          requestAnimationFrame(loop); 
          spawnWave(game.nextWave); 
        }
      });

      function setBattleMessage(text, duration = 2.0, color = '#ff00ff') {
        game.battleMessage.text = text;
        game.battleMessage.timer = duration;
        game.battleMessage.color = color;
      }
      
      function toast(msg, ms=1100){ 
        // Route all toasts through the combo area as battle messages
        setBattleMessage(msg, ms/1000, '#ff00ff');
      }
      
      function showAchievement(text){
        const div = document.createElement('div');
        div.className = 'achievement';
        div.textContent = text;
        document.body.appendChild(div);
        setTimeout(()=>div.remove(), 2000);
      }

      // ============================
      // Boot (MENU)
      // ============================
      function buildMenu(){ 
        ui.ovTitle.innerHTML = '<div class="epic-title" style="text-align: center; width: 100%; margin: 0 auto;">⚔️ NEON KNIGHTS ⚔️</div>'; 
        ui.ovSub.textContent='DEFEND THE NEON REALM'; 
        ui.ovSub.style.textAlign = 'center';
        ui.ovSub.style.width = '100%';
        ui.ovSub.style.margin = '0 auto';
        ui.ovBody.innerHTML = `
          <div style="display: grid; grid-template-columns: 30% 30% 30%; gap: 20px; width: 90%; margin: 0 auto; padding: 20px 0; justify-content: center;">
            <!-- WASD Teleport Column -->
            <div class="card" style="text-align: center; background: linear-gradient(135deg, rgba(0,255,255,0.15), rgba(0,255,255,0.05)); border: 2px solid #00ffff; min-height: 180px; display: flex; flex-direction: column; justify-content: center; padding: 20px;">
              <div class="title" style="color: #00ffff; text-shadow: 0 0 10px #00ffff; margin-bottom: 15px;">TELEPORT</div>
              <div style="font-size: 48px; margin: 20px 0;">WASD MOVE</div>
              <div class="desc">
                <strong style="color: #00ffff">Unlock power shots after movement</strong>
              </div>
            </div>
            
            <!-- Time Slow Column -->
            <div class="card" style="text-align: center; background: linear-gradient(135deg, rgba(255,255,0,0.15), rgba(255,255,0,0.05)); border: 2px solid #ffff00; min-height: 180px; display: flex; flex-direction: column; justify-content: center; padding: 20px;">
              <div class="title" style="color: #ffff00; text-shadow: 0 0 10px #ffff00; margin-bottom: 15px;">TIME SLOW</div>
              <div style="font-size: 48px; margin: 20px 0;">HOLD SHIFT</div>
              <div class="desc">
                Slow down time<br>
                <strong style="color: #ffff00">Enhanced sniper accuracy</strong>
              </div>
            </div>
            
            <!-- Power Shot Column -->
            <div class="card" style="text-align: center; background: linear-gradient(135deg, rgba(255,0,255,0.15), rgba(255,0,255,0.05)); border: 2px solid #ff00ff; min-height: 180px; display: flex; flex-direction: column; justify-content: center; padding: 20px;">
              <div class="title" style="color: #ff00ff; text-shadow: 0 0 10px #ff00ff; margin-bottom: 15px;">POWER SHOT</div>
              <div style="font-size: 48px; margin: 20px 0;">HOLD RIGHT</div>
              <div class="desc">
                Charge devastating attacks
              </div>
            </div>
          </div>`; 
        showOverlay(true); 
      }
      
      buildMenu();
      render();

    </script>
  </body>
  </html>
  </html>